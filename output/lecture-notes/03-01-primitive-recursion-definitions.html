<!DOCTYPE html>
<html>
<head>
      <link rel="icon" href="data:,">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="../lecture-notes.css" />
    <link rel="stylesheet" type="text/css" href="../TI.css" />
    <link rel="stylesheet" type="text/css" href="../tooltip-3003.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script type="text/javascript" src="../numbered-title.js"></script>
    <script type="text/javascript" src="../mathjax_setup.js"></script>
    <script type="text/javascript" src="../carousel.js"></script>
    <script type="text/javascript" src="../sendCmdTo3003.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>
<section
  count="16"
  title_gr="Rekursion: Motivation und Definitionen"
  title_en="primitive recursion definitions"
  number="3.1"
  counter="DefCtr"
  counter="ExoCtr"
  path="/lecture-notes16"
>
  <div
    id="link-to-toc"
  >
    <a
      href="../vorlesungsskript.html"
    >Inhaltsverzeichnis</a><a
      href="03-00-Computability-NaturalNumbers.html"
    >&lt;&lt; Kapitel 3.0</a>
  </div>
  <div
    id="link-to-overview"
    style="text-align: end"
  >
    <a
      href="/"
    >zur Kursübersicht</a><a
      href="03-02-primitive-recursion-constructions.html"
    >Kapitel 3.2 &gt;&gt;</a>
  </div>
  <div
    id="rightSideWrapper"
  >
    <div
      class="content"
    >
      <div
        class="chapter"
      >
        <div
          class="subChapter"
        >
          <h1
            class="hidden-title"
          >
            <span
              class="subChapterTitle"
            >3.1
              Primitive Rekursion: Motivation und Definitionen</span>
          </h1>
          <p>
            Primitive Rekursion ist ein Versuch, Berechbarkeit von Funktionen \(f: \N^k \rightarrow \N\)
            anhand
            eines "Baukastenprinzips" zu modellieren. Man stellt gewisse Basisfunktionen als "offensichtlich
            berechenbar" zur Verfügung und beschreibt 
            <i>Kombinatoren</i>, die aus bereits konstruierten
            Funktionen neue bauen können. Die primitiv-rekursiven Funktionen sind dann all jene, die
            mittels der Kombinatoren von den Basisfunktionen ausgehend konstruiert werden können.
            Die Basisfunktionen sind:
          </p>
          $$\begin{align*}
          \zero:&\N^* \rightarrow \N \\
          \vec{x}&amp;\mapsto 0
          \end{align*}$$
          $$\begin{align*}
          \succ: \N&amp;\rightarrow \N \\
          x&amp;\mapsto x+1
          \end{align*}$$
          <p>
            Sind diese Funktionen "offensichtlich berechenbar"? Ich würde sagen, die fundamentale Eigenschaft
            der natürlichen Zahlen ist, dass jede Zahl einen Nachfolger (successor) hat; daher ist irgendwie
            klar, dass \(\succ\) berechen bar ist. Aber seien wir vorsichtig: wenn wir für natürliche Zahlen
            die Dezimaldarstellung (oder Binärdarstellung, spielt keine Rolle) verwenden, dann ist
            die Operation \(x \mapsto x+1\) bereits eine nicht ganz triviale Operation, sie erfordert
            beispielsweise Schleifen (von rechts nach links durchgehen), if-then-else-Ausdrücke (gibt es ein
            Carry?)
            etc. Daher sollten Sie so tun, also würden wir natürliche Zahlen in 
            <i>unärer Schreibweise</i>
            (auhc Steinzeitnotation genannt)
            darstellen, also vier \( = 1111\), sieben = \(= 1111111\). Jezt
            brauchen wir für succ kein if-then-else und keine Schleifen, denn
            \(\succ(x) = 1x\).
          </p>
          <p>
            Eine weitere Klasse von "offensichtlich" berechenbaren Funktionen sind die sogenannten
            Projektionen
            \(\pi^n_k\), definiert als
            $$\begin{align*}
            \pi^n_k : \N^n&amp;\rightarrow \N \\
            \vec{x}&amp;\mapsto x_k \ .
            \end{align*}$$
            Irgendwie sollte auch hier klar sein, dass die Vorschrift "gib von den 3 Argumenten, die Du
            erhältst, das erste zurück" ohne Zweifel "berechenbar" ist.
            Weil wir bald alles in einem Python-Framework implementieren werden, sei angemerkt,
            dass ich die Zählung der Indizes bei 0 beginnen lasse, also zum Beispiel
            $$\begin{align*}
            \pi^3_0: (x,y,z) \mapsto x \\
            \pi^3_1: (x,y,z) \mapsto y \ .
            \end{align*}$$
            Auch die Stelligkeit \(n\) lasse ich oft weg und schreibe einfach \(\pi_k\) statt \(\pi^n_k\).
          </p>
          <b>Kombinatoren.</b>
          Die primitive Rekursion stellt zwei Kombinatoren zur Verfügung: Komposition (Verknüpfung) und
          primitive Rekursion.
          <div
            class="well container theorem"
          >
            <span
              class="numbered-title"
            >Definition 
              <NumberedTitle>3.1.1</NumberedTitle>
               
            </span><b>(Komposition)</b>
            Sei \(f: \N^k \rightarrow \N\) und
            \(g_1, \dots, g_k: \N^l \rightarrow \N\). Dann ist
            \(\comp(f, g_1, \dots, g_k)\) die Funktion
            $$\begin{align*}
            \N^l&amp;\rightarrow \N \\
            \vec{x}&amp;\mapsto f(g_1(\vec{x}), \dots, g_k(\vec{x}))
            \end{align*}$$
            Graphisch können Sie sich Komposition so vorstellen:
            <figure>
              <img
                style="height:15em"
                src="../img/primitive-rekursion/composition.svg"
                loading="lazy"
              >
            </figure>
          </div>
          <p>
            Um aber komplexere Operationen implementieren zu können, brauchen wir eine Art von Schleife.
            Was ist die einfachste Art von Schleife oder Rekursion. Wir dürfen nur eine sehr beschränkte
            Form der Rekursion verwenden:
          </p>
          <div
            class="well container theorem"
          >
            <span
              class="numbered-title"
            >Definition 
              <NumberedTitle>3.1.2</NumberedTitle>
               
            </span><b>Primitive Rekursion</b>
            Seien \(g: \N^k \rightarrow \N\) und \(h: \N^{k+2} \rightarrow \N\). Wir
            definieren eine neue Funktion \(f: \N^{k+1} \rightarrow \N\) wie folgt:
            $$\begin{align*}
            f : \N^{k+1}&amp;\rightarrow \N \\
            (t, \vec{x})&amp;\rightarrow \begin{cases}
            g(\vec{x})&amp;\textnormal{ if $t=0$} \\
            h(f(t-1, \vec{x}), t-1, \vec{x})&amp;\textnormal{ if $t \geq 1$}.
            \end{cases}
            \end{align*}$$
            Für diese Konstruktion schreiben wir kompakt
            \(f := \primrec(g,h)\).
          </div>
          <p>
            Wenn Sie Rekursionshasser sind, dann können Sie sich es als Funktion mit einer
            
            <code>
              for
            </code>
            -Schleife
            vorstellen, in der nur eine lokale Variable erlaubt ist:
          </p>
<pre
  class="listing"
>

<code>
def PrimRec(g, h):
</code>

 
<code>
def f(t,*x):
</code>

     
<code>
temp = g(*x)
</code>

     
<code>
for i in range(t):
</code>

 
<code>
temp = h(temp, i, *x)
</code>

     
<code>
return temp
</code>

 
<code>
return f
</code>
 
</pre>
          <p>
            Die Forderung, dass man nur 
            <i>eine</i>
             lokale Variable durch die Schleife führen darf, scheint
            sehr restriktiv; es ist aber wohl die einfachste Form einer Schleife, die wirklich etwas
            "schleifenhaftes" tut.
          </p>
          <div
            class="well container theorem"
          >
            <span
              class="numbered-title"
            >Demo.</span>Speichern Sie die Datei 
            <a
              href="../code/primitive-recursion/primrec.py"
            >primrec.py</a>
             auf
            Ihrem Rechner.
            Diese Datei stellt ein Framework für die Implementierung primitiv rekursiver Funktionen zur
            Verfügung.
            Insbesondere implementiert sie die folgenden Funktion \(\N^k \rightarrow \N\):
            $$\begin{align*}
            {\rm zero}:&amp;\vec{x} \mapsto 0 \\
            {\rm succ}:&amp;x \mapsto x+1
            \end{align*}$$
            als "übliche" Python-Funktionen. Darüberhinaus implementiert sie die folgenden
            Kombinatoren, welche Ihnen nach den
            Regeln der primitiven Rekursion neue Funktionen erstellt:
            <ul>
              <li>
                
                <code>
                  Proj(k)
                </code>
                : erzeugt die Funktion
                $$\begin{align*}
                \pi_k : \N^*&amp;\rightarrow \N \\
                \vec{x}&amp;\mapsto x_k \ .
                \end{align*}$$
              </li>
              <li>
                
                <code>
                  Comp(f, g0, g1, ...)
                </code>
                : erzeugt die Funktion
                $$\begin{align*}
                \vec{x} \mapsto f(g0(x), g1(x), ...)
                \end{align*}$$
                Sie als User müssen sicherstellen, dass die Stelligkeit von \(f\) mit der Anzahl der als
                \(g_i\) übergebenen Funktionen
                übereinstimmt.
              </li>
              <li>
                
                <code>
                  PrimRec(g,h)
                </code>
                : erzeugt die Funktion
                $$\begin{align*}
                (t, \vec{x}) \mapsto \begin{cases}
                g(\vec{x})&amp;\textnormal{ if $t=0$,} \\
                h(f(t-1, \vec{x}), t-1, \vec{x})&amp;\textnormal{ if $t \geq 1$.}
                \end{cases}
                \end{align*}$$
              </li>
            </ul>
            <p>
              Wenn wir die primitive Rekursion als "Programmiersprache" betrachten, dann heißt das, dass
              wir
              neue Funktionen bauen dürfen, indem wir 
              <code>
                zero,succ,Proj,Comp,PrimRec
              </code>
               verwenden,
              aber nicht selbst Python-Funktionen schreiben. Wir dürfen also nie selbst Integers in die
              Hand nehmen.
            </p>
            <p>
              Lassen Sie mich das am Beispiel der Addition erklären. Ich will eine Funktion
              \({\rm add}: \N^2 \rightarrow \N\) schreiben, die ihre beiden Argumente addiert.
              Ich darf also nicht einfach python programmieren und
            </p>
<pre
  style="color:red; background-color: yellow;"
  class="listing"
>

<code>
def add(x,y):
</code>

 
<code>
return x + y
</code>

</pre>
            <p>
              schreiben, denn unsere "Programmiersprache" ist Primitive Rekursion, nicht Python! Wir
              müssen uns 
              <code>
                add
              </code>
               aus den Kombinatoren zusammenbasteln. Ich schreibe
              nun \({\rm add}(t,x)\) statt \({\rm add}(x,y)\), um den Rekursionsparameter \(t\) deutlich
              zu machen.
            </p>
            $$\begin{align*}
            {\rm add}(t,x)&amp;= \begin{cases}
            x&amp;\textnormal{ if $t=0$} \\
            {\rm succ}({\rm add}(t-1,x))&amp;\textnormal{ if $t \geq 1$.}
            \end{cases} \\
            &amp;= \begin{cases}
            \pi_0(x)&amp;\textnormal{ if $t=0$} \\
            {\rm succ}(\pi_0({\rm add}(t-1,x), t-1, x))&amp;\textnormal{ if $t \geq 1$.}
            \end{cases} \\
            \end{align*}$$
            <p>
              Wir sehen also, dass dies eine Anwendung der primitiven Rekursion ist mit
              \(g = \pi_0\) und \(h = {\comp}(\succ, \pi_0)\), also
            </p>
<pre
  class="listing"
>

<code>
p0 = Proj(0)
</code>


<code>
add = PrimRec (p0, Comp(succ,p0))
</code>

</pre>
          </div>
          <div
            class="well well-lg numbered-exercise container"
          >
            <span
              class="numbered-title"
            >Übungsaufgabe 
              <NumberedTitle>3.1.1</NumberedTitle>
               
            </span>Zeigen Sie, dass die folgenden Funktionen primitiv-rekursiv sind, und implementieren Sie sie
            in meinem Python-Framework, so wie ich Addition mit
            
            <code>
              add = PrimRec (p0, Comp(succ,p0))
            </code>
            
            implementiert habe:
            <ol>
              <li>
                \({\rm mult}: (x,y) \mapsto x*y\)
              </li>
              <li>
                \({\rm exp}: (a,b) \mapsto a^b\)
              </li>
              <li>
                \({\rm pred}: x \mapsto \max(0, x-1)\)
              </li>
              <li>
                \({\rm minus}: (x,y) \mapsto x-y\)
              </li>
            </ol>
            <p>
              <b>Tip:</b>
               Für exp und minus ist es einfacher, die Argumente "umgedreht" zu
              betrachten,
              also \((a,b) \mapsto b^a\) und \((x,y) \mapsto y-x\).
            </p>
          </div>
          <div
            class="well well-lg numbered-exercise container"
          >
            <span
              class="numbered-title"
            >Übungsaufgabe 
              <NumberedTitle>3.1.2</NumberedTitle>
               
            </span>Wenn Sie die vorherige Übungsaufgabe gelöst (oder darüber aufgegeben) haben,
            sehen Sie sich die Datei<a
              href="../code/primitive-recursion/stockpile.py"
            >stockpile.py</a>
             an,
            in der ich diese Funktionen zum Großteil implementiert habe (basierend auf
            den Übungen, die wir direkt in der Vorlesung gemacht haben).
            <p>
              Experimentieren Sie weiter und implementieren Sie "Boolesche" Prädikate und Funktionen wie
            </p>
            <ul>
              <li>
                
                <code>
                  isPositive
                </code>
                
              </li>
              <li>
                
                <code>
                  greaterThan, lessThan, greaterEqual, lessEqual
                </code>
                
              </li>
              <li>
                
                <code>
                  max, min
                </code>
                
              </li>
              <li>
                
                <code>
                  ifThenElse(x,y,z)
                </code>
                : dies soll \(z\) zurückliefern, falls
                \(x=0\) (also 
                <code>
                  false
                </code>
                ) ist, und \(y\) sonst.
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>
</body>
