<!DOCTYPE html>
<html>
<head>
      <link rel="icon" href="data:,">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="../lecture-notes.css" />
    <link rel="stylesheet" type="text/css" href="../TI.css" />
    <link rel="stylesheet" type="text/css" href="../tooltip-3003.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script type="text/javascript" src="../numbered-title.js"></script>
    <script type="text/javascript" src="../mathjax_setup.js"></script>
    <script type="text/javascript" src="../carousel.js"></script>
    <script type="text/javascript" src="../sendCmdTo3003.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>
<section
  count="20"
  .="BookLevelSectionCounter 20"
  title_gr="Sprachen - Einführung und Beispiele"
  title_en="formal languages"
  number="4.0"
  counter="DefCtr"
  counter="ExoCtr"
  path="/lecture-notes20"
>
  <div id="link-to-toc">
    <a href="../vorlesungsskript.html">Inhaltsverzeichnis</a><a href="03-04-mu-recursion.html">&lt;&lt; Kapitel 3.4</a>
  </div>
  <div
    id="link-to-overview"
    style="text-align: end"
  >
    <a href="/">zur Kursübersicht</a><a href="04-01-regular-grammars.html">Kapitel 4.1 &gt;&gt;</a>
  </div>
  <div id="rightSideWrapper">
    <div class="content">
      <div class="chapter">
        <h1 class="hidden-title">
          <span class="chapterTitle">4.
            Formale Sprachen - Einführung und Beispiele</span>
        </h1>
        <div class="subChapter">
          Hier sehen Sie einige Beispiele für gültige und ungültige Email-Adressen. Mit
          <i>gültig</i>
          meine ich, dass sie syntaktisch korrekt sind, ungeachtet, ob ein Konto mit dieser Email-Adresse
          besteht.
<pre class="container">
thomas.schmitz@hszg.de                              <span class="comment">Gültig</span>dominik@cs.sjtu.edu.cn                              <span class="comment">Gültig</span>raffaela@mayer@gmail.com                            <span class="comment">Ungültig: @ kommt zweimal vor</span>lorenz.klein@greatest/company/in/the/world.com      <span class="comment">Ungültig: Domain-Name darf kein / enthalten</span>.schlaumeier@gmail.com                              <span class="comment">Ungültig: Google will kein . an erster Stelle</span>
</pre>
          Hier sehen Sie den Teil eines HTML-Dokuments. Beachten Sie die typische
          hierarchisch-geschachtelte
          Struktur (sie müssen es nicht im Detail lesen):
          <style>
            .StartTag,
            .EndTag {
            color: blue;
            }
            .AttributeValueDoubleQuote,
            .AttributeValueSingleQuote {
            color: orange
            }
            .RawText {
            font-style: italic;
            }
            .AttributeName {
            color: limegreen;
            }
          </style>
<pre class="container">
<span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="StartTag">div</span><span class="WaitingForAttribute"> </span><span class="AttributeName">class</span><span class="WaitingForValue">=</span><span class="SingleQuote">'</span><span class="AttributeValueSingleQuote">carousel-inner</span><span class="SingleQuote">'</span><span class="WaitingForAttribute"> </span><span class="AttributeName">style</span><span class="WaitingForValue">=</span><span class="SingleQuote">'</span><span class="AttributeValueSingleQuote">display:inline-block</span><span class="SingleQuote">'</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="StartTag">div</span><span class="WaitingForAttribute"> </span><span class="AttributeName">class</span><span class="WaitingForValue">=</span><span class="SingleQuote">'</span><span class="AttributeValueSingleQuote">item active</span><span class="SingleQuote">'</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="StartTag">p</span><span class="GreaterThanBracket">&gt;</span><span class="RawText">$110 x + 794$</span><span class="LessThanBracket">&lt;</span><span class="EndTag">/p</span><span class="GreaterThanBracket">&gt;</span><span class="LessThanBracket">&lt;</span><span class="StartTag">img</span><span class="WaitingForAttribute"> </span><span class="AttributeName">loading</span><span class="WaitingForValue">=</span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">lazy</span><span class="DoubleQuote">"</span><span class="WaitingForAttribute"> </span><span class="AttributeName">src</span><span class="WaitingForValue">=</span><span class="SingleQuote">'</span><span class="AttributeValueSingleQuote">../img/hash/hashfunction<i>110</i>794.svg</span><span class="SingleQuote">'</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="EndTag">/div</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="StartTag">div</span><span class="WaitingForAttribute"> </span><span class="AttributeName">class</span><span class="WaitingForValue">=</span><span class="SingleQuote">'</span><span class="AttributeValueSingleQuote">item</span><span class="SingleQuote">'</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="StartTag">p</span><span class="GreaterThanBracket">&gt;</span><span class="RawText">$502 x + 121$</span><span class="LessThanBracket">&lt;</span><span class="EndTag">/p</span><span class="GreaterThanBracket">&gt;</span><span class="LessThanBracket">&lt;</span><span class="StartTag">img</span><span class="WaitingForAttribute"> </span><span class="AttributeName">loading</span><span class="WaitingForValue">=</span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">lazy</span><span class="DoubleQuote">"</span><span class="WaitingForAttribute"> </span><span class="AttributeName">src</span><span class="WaitingForValue">=</span><span class="SingleQuote">'</span><span class="AttributeValueSingleQuote">../img/hash/hashfunction<i>502</i>121.svg</span><span class="SingleQuote">'</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="EndTag">/div</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="StartTag">div</span><span class="WaitingForAttribute"> </span><span class="AttributeName">class</span><span class="WaitingForValue">=</span><span class="SingleQuote">'</span><span class="AttributeValueSingleQuote">item</span><span class="SingleQuote">'</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="StartTag">p</span><span class="GreaterThanBracket">&gt;</span><span class="RawText">$617 x + 5$</span><span class="LessThanBracket">&lt;</span><span class="EndTag">/p</span><span class="GreaterThanBracket">&gt;</span><span class="LessThanBracket">&lt;</span><span class="StartTag">img</span><span class="WaitingForAttribute"> </span><span class="AttributeName">loading</span><span class="WaitingForValue">=</span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">lazy</span><span class="DoubleQuote">"</span><span class="WaitingForAttribute"> </span><span class="AttributeName">src</span><span class="WaitingForValue">=</span><span class="SingleQuote">'</span><span class="AttributeValueSingleQuote">../img/hash/hashfunction<i>617</i>5.svg</span><span class="SingleQuote">'</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="EndTag">/div</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="StartTag">div</span><span class="WaitingForAttribute"> </span><span class="AttributeName">class</span><span class="WaitingForValue">=</span><span class="SingleQuote">'</span><span class="AttributeValueSingleQuote">item</span><span class="SingleQuote">'</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="StartTag">p</span><span class="GreaterThanBracket">&gt;</span><span class="RawText">$815 x + 562$</span><span class="LessThanBracket">&lt;</span><span class="EndTag">/p</span><span class="GreaterThanBracket">&gt;</span><span class="LessThanBracket">&lt;</span><span class="StartTag">img</span><span class="WaitingForAttribute"> </span><span class="AttributeName">loading</span><span class="WaitingForValue">=</span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">lazy</span><span class="DoubleQuote">"</span><span class="WaitingForAttribute"> </span><span class="AttributeName">src</span><span class="WaitingForValue">=</span><span class="SingleQuote">'</span><span class="AttributeValueSingleQuote">../img/hash/hashfunction<i>851</i>562.svg</span><span class="SingleQuote">'</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="EndTag">/div</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="StartTag">div</span><span class="WaitingForAttribute"> </span><span class="AttributeName">class</span><span class="WaitingForValue">=</span><span class="SingleQuote">'</span><span class="AttributeValueSingleQuote">item</span><span class="SingleQuote">'</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="StartTag">p</span><span class="GreaterThanBracket">&gt;</span><span class="RawText">$868 x + 858$</span><span class="LessThanBracket">&lt;</span><span class="EndTag">/p</span><span class="GreaterThanBracket">&gt;</span><span class="LessThanBracket">&lt;</span><span class="StartTag">img</span><span class="WaitingForAttribute"> </span><span class="AttributeName">loading</span><span class="WaitingForValue">=</span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">lazy</span><span class="DoubleQuote">"</span><span class="WaitingForAttribute"> </span><span class="AttributeName">src</span><span class="WaitingForValue">=</span><span class="SingleQuote">'</span><span class="AttributeValueSingleQuote">../img/hash/hashfunction<i>868</i>858.svg</span><span class="SingleQuote">'</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="EndTag">/div</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="StartTag">div</span><span class="WaitingForAttribute"> </span><span class="AttributeName">class</span><span class="WaitingForValue">=</span><span class="SingleQuote">'</span><span class="AttributeValueSingleQuote">item</span><span class="SingleQuote">'</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="StartTag">p</span><span class="GreaterThanBracket">&gt;</span><span class="RawText">$915 x + 320$</span><span class="LessThanBracket">&lt;</span><span class="EndTag">/p</span><span class="GreaterThanBracket">&gt;</span><span class="LessThanBracket">&lt;</span><span class="StartTag">img</span><span class="WaitingForAttribute"> </span><span class="AttributeName">loading</span><span class="WaitingForValue">=</span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">lazy</span><span class="DoubleQuote">"</span><span class="WaitingForAttribute"> </span><span class="AttributeName">src</span><span class="WaitingForValue">=</span><span class="SingleQuote">'</span><span class="AttributeValueSingleQuote">../img/hash/hashfunction<i>915</i>320.svg</span><span class="SingleQuote">'</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="RawText"> </span><span class="LessThanBracket">&lt;</span><span class="EndTag">/div</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span><span class="LessThanBracket">&lt;</span><span class="EndTag">/div</span><span class="WaitingForAttribute"> </span><span class="AttributeName">class</span><span class="WaitingForValue">=</span><span class="SingleQuote">'</span><span class="AttributeValueSingleQuote">carousel-inner</span><span class="SingleQuote">'</span><span class="GreaterThanBracket">&gt;</span> 
</pre>
          Hier sehen Sie einen Ausschnitt aus einem Elm-Programm (auch diesen müssen Sie nicht im
          Detail lesen):
<pre class="listing container">
<code>find : Bst -&gt; String -&gt; Maybe String</code>
<code>find tree key =</code>
 <code>case tree of</code>
 <code>Empty _ -&gt;</code>
 <code>Nothing</code>
``
 <code>Node ( keyHere, valueHere ) leftChild rightChild -&gt;</code>
 <code>if key == keyHere then</code>
 <code>Just valueHere</code>
``
 <code>else if key&lt; keyHere then</code>
 <code>find leftChild key</code>
``
 <code>else</code>
 <code>find rightChild key</code>
</pre>
          Als letztes Beispiel sehen Sie hier eine svg-Datei. Dies ist ein Dateiformat für Vektorgrafiken.
          In
          diesem
          Falle ein Kreis mit einer Geraden:
          <img
            style="height:4em"
            src="../img/svg-example.svg"
          >
<pre class="listing container">
<code><span class="RawText"></span><span class="LessThanBracket">&lt;</span><span class="StartTag">?xml</span><span class="WaitingForAttribute"> </span><span class="AttributeName">version</span><span class="WaitingForValue">=</span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">1.0</span><span class="DoubleQuote">"</span><span class="WaitingForAttribute"> </span><span class="AttributeName">encoding</span><span class="WaitingForValue">=</span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">UTF-8</span><span class="DoubleQuote">"</span><span class="AttributeName">?</span><span class="GreaterThanBracket">&gt;</span><span class="LineBreak"></span></code><span class="LineBreak"></span><span class="WaitingForAttribute"> </span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">http://www.w3.org/2000/svg</span><span class="DoubleQuote">"</span><span class="WaitingForValue">=</span><span class="AttributeName">xmlns</span><span class="WaitingForAttribute"> </span><span class="StartTag">svg</span><span class="LessThanBracket">&lt;</span><code>
</code><span class="LineBreak"></span><span class="WaitingForAttribute"> </span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">http://www.w3.org/1999/xlink</span><span class="DoubleQuote">"</span><span class="WaitingForValue">=</span><span class="AttributeName">xmlns:xlink</span><span class="WaitingForAttribute"> </span><code>
</code><span class="LineBreak"></span><span class="WaitingForAttribute"> </span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">102pt</span><span class="DoubleQuote">"</span><span class="WaitingForValue">=</span><span class="AttributeName">height</span><span class="WaitingForAttribute"> </span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">102pt</span><span class="DoubleQuote">"</span><span class="WaitingForValue">=</span><span class="AttributeName">width</span><span class="WaitingForAttribute"> </span><code>
</code><span class="LineBreak"></span><span class="WaitingForAttribute"> </span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">0 0 102 102</span><span class="DoubleQuote">"</span><span class="WaitingForValue">=</span><span class="AttributeName">viewBox</span><span class="WaitingForAttribute"> </span><code>
</code><span class="LineBreak"></span><span class="GreaterThanBracket">&gt;</span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">1.1</span><span class="DoubleQuote">"</span><span class="WaitingForValue">=</span><span class="AttributeName">version</span><span class="WaitingForAttribute"> </span><code>
</code><span class="LineBreak"></span><span class="GreaterThanBracket">&gt;</span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">surface2322</span><span class="DoubleQuote">"</span><span class="WaitingForValue">=</span><span class="AttributeName">id</span><span class="WaitingForAttribute"> </span><span class="StartTag">g</span><span class="LessThanBracket">&lt;</span><code>
</code><span class="LineBreak"></span><span class="WaitingForAttribute"> </span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">fill:none;stroke-width:0.4;stroke:rgba(0,0,0,100);</span><span class="DoubleQuote">"</span><span class="WaitingForValue">=</span><span class="AttributeName">style</span><span class="WaitingForAttribute"> </span><span class="StartTag">circle</span><span class="LessThanBracket">&lt;</span><code>
</code><span class="LineBreak"></span><span class="GreaterThanBracket">&gt;</span><span class="AttributeName">/</span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">40</span><span class="DoubleQuote">"</span><span class="WaitingForValue">=</span><span class="AttributeName">r</span><span class="WaitingForAttribute"> </span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">51</span><span class="DoubleQuote">"</span><span class="WaitingForValue">=</span><span class="AttributeName">cy</span><span class="WaitingForAttribute"> </span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">51</span><span class="DoubleQuote">"</span><span class="WaitingForValue">=</span><span class="AttributeName">cx</span><span class="WaitingForAttribute"> </span><code>
</code><span class="LineBreak"></span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">fill:none;stroke-width:0.4;stroke:rgba(0,0,0,100);</span><span class="DoubleQuote">"</span><span class="WaitingForValue">=</span><span class="AttributeName">style</span><span class="WaitingForAttribute"> </span><span class="StartTag">path</span><span class="LessThanBracket">&lt;</span><code>
</code><span class="LineBreak"></span><span class="RawText"> </span><span class="GreaterThanBracket">&gt;</span><span class="AttributeName">/</span><span class="DoubleQuote">"</span><span class="AttributeValueDoubleQuote">M 50 50 l 33.5 -22.5</span><span class="DoubleQuote">"</span><span class="WaitingForValue">=</span><span class="AttributeName">d</span><span class="WaitingForAttribute"> </span><code>
</code><span class="LineBreak"></span><span class="GreaterThanBracket">&gt;</span><span class="EndTag">/g</span><span class="LessThanBracket">&lt;</span><code>
</code><span class="LineBreak"></span><span class="GreaterThanBracket">&gt;</span><span class="EndTag">/svg</span><span class="LessThanBracket">&lt;</span><code>
</code>
</pre>
          Was haben diese vier Beispiele gemeinsam? Es handelt sich in allen Fällen um
          <i>Daten</i>, die
          in
          einem bestimmten festgelegten
          <i>Format</i>
          dargelegt werden. Soll ein Rechner etwas sinnvolles damit anfangen (zum Beispiel das
          Elm-Programm
          starten oder die HTML-Seite oder die Svg-Datei
          auf dem Bildschirm darstellen), muss er dieses Format erst einmal "verstehen", also den bloßen
          String aus ASCII-Zeichen umwandeln in eine logisch
          sinnvolle Struktur. Und genau darum geht es in den Formalen Sprachen: wir wollen Begriffe,
          Regeln,
          Methoden, Algorithmen entwickeln, um
          Daten, die in einem bestimmten Format vorliegen, zu verarbeiten; ja auch erst einmal überhaupt
          Begriffe festlegen, wie man solche Formate definiert.
          <Topic>
            Korrekte Email-Adressen
          </Topic>
          Kommen wir auf unser erstes, einfachstes Beispiel zurück: die Email-Adressen. Können Sie
          möglichst
          präzise und möglichst formal beschreiben, wie eine korrekte
          Email-Adresse auszusehen hat? Hier versuche ich es einmal:
          <Highlight>
            Eine Emailadresse besteht aus einem
            <i>Benutzernamen</i>
            und einem
            <i>Domainnamen</i>, die
            mit
            einem
            <code>@</code>
            verbunden sind.
            Der Benutzername ist ein nichtleerer String bestehend aus Groß- und Kleinbuchstaben, Zahlen, und
            Punkten (<code>.</code>).
            Erster und letzter Buchstaben dürfen keine Punkte sein, außerdem dürfen keine zwei Punkte
            nebeneinander stehen.
            Der Domainname ist eine Folge von mindestenes zwei
            <i>Labels</i>, die jeweils mit einem
            <code>.</code>
            separiert sind. Ein Label
            ist ein nichtleerer String aus Groß- und Kleinbuchstaben, Zahlen und dem Bindestrich
            (<code>-</code>).
          </Highlight>
          Die genauen Regeln mögen von Anbieter zu Anbieter variieren; ich habe mich mal an das gehalten,
          was
          ich experimentell bei
          <code>gmail.com</code>
          herausgefunden
          habe. Die obige Beschreibung ist (hoffentlich) verständlich und präzise und unzweideutig.
          Allerdings
          ist sie in natürlicher Sprache verfasst;
          es ist beispielsweise nicht klar, wie ein Rechner aus der obigen Beschreibung einen Algorithmus
          konstruieren kann, der Korrektheit einer Email-Adresse überprüft.
          Außerdem schleichen sich bei natürlicher Sprache schnell Zweideutigkeiten ein, die a priori
          nicht
          immer zu erkennen sind.
          Wir wollen daher ein formales Regelwerk erstellen, wie wir Formate dieser Art vollständig und
          eindeutig beschreiben können.
          Ich werde dies nun Schritt für Schritt entwickeln, erst informell anhand des
          Email-Adressen-Beispiels und dann, im nächsten Kapitel, formal und abstrakt.
          Eine Emailadresse ist von der Form
          <i>Benutzername</i>`@`<i>Domainnname</i>. Dies
          können wir als
          <i>Ableitungsregel</i>
          darstellen:
<pre class="container">
&lt;EmailAdress&gt; <b>-&gt;</b>&lt;User&gt; @&lt;Domain&gt;
</pre>
          Wie können wir nun beispielsweise eine ähnliche Ableitungsregeln für
          <code>&lt;Domain&gt;</code>
          erstellen? Eine
          <code>&lt;Domain&gt;</code>
          soll
          eine Folge aus mindestens zwei
          <code>&lt;Label&gt;</code>
          sein, jeweils durch einen
          `.`
          separiert. Wir erreichen dies, indem wir einen an Rekursion
          erinnernden Trick anwenden: entweder gibt es genau zwei Labels oder die Domain beginnt mit einem
          Label,
          gefolgt von einem Punkt und wiederum einer
          <i>Folge von mindestens zwei durch
            <code>.</code>
            separierten Labels</i>,
          also wiederum etwas, das wie ein Domainname aussieht. Daher:
<pre class="container">
&lt;Domain&gt; <b>-&gt;</b>&lt;Label&gt; .&lt;Label&gt;
&lt;Domain&gt; <b>-&gt;</b>&lt;Label&gt; .&lt;Domain&gt;
</pre>
          Wir geben also
          <i>zwei</i>
          Möglichkeiten an, wie mit einem
          <code>&lt;Domain&gt;</code>
          zu
          verfahren ist.
          Was ist nun
          <code>&lt;Label&gt;</code>? Dies ist eine nichtleere Folge von in Domainnamen
          erlaubten
          Zeichen.
          Diese sind alphanumerisch (Buchstaben und Zahlen) und der Strich
          <code>-</code>
          (in der Praxis
          sind
          eventuell noch weitere Zeichen erlaubt;
          im Ernstfall hängt dies davon ab, was die Domain Name Server des jeweiligen Landes / der
          jeweiligen
          Top-Level-Domain erlauben, siehe
          zum Beispiel
          <a href="https://en.wikipedia.org/wiki/Internationalized_domain_name">Wikipedia:
            Internationalized Domain Name</a>).
          Wie formulieren wir
          <i>nichtleere Folge von ...</i>
          mit unserer
          <code>--&gt;</code>-Notation?
          Wieder mit dem Rekursionstrick:
<pre class="container">
&lt;Label&gt; <b>-&gt;</b>&lt;AlphaNumOrDash&gt;
&lt;Label&gt; <b>-&gt;</b>&lt;AlphaNumOrDash&gt;&lt;Label&gt;
&lt;AlphaNumOrDash&gt; <b>-&gt;</b>&lt;AlphaNum&gt;
&lt;AlphaNumOrDash&gt; <b>-&gt;</b> - 
</pre>
          Nun müssen wir noch Regeln für
          <code>&lt;AlphaNum&gt;</code>
          angeben. Hier führen wir eine
          weitere
          Konvention ein: nämlich, dass wir
          verschiedene Alternativen mit einem senkrechten Strich | separieren:
<pre class="container">
&lt;AlphaNum&gt; <b>-&gt;</b> a <b>|</b> b <b>|</b> c <b>|</b> d <b>|</b> e <b>|</b> f <b>|</b> g <b>|</b> h <b>|</b> i <b>|</b> j <b>|</b> k <b>|</b> l <b>|</b> m <b>|</b> n <b>|</b> o <b>|</b> p <b>|</b> q <b>|</b> r <b>|</b> s <b>|</b> t <b>|</b> u <b>|</b> v <b>|</b> w <b>|</b> x <b>|</b> y <b>|</b> z
&lt;AlphaNum&gt; <b>-&gt;</b> A <b>|</b> B <b>|</b> C <b>|</b> D <b>|</b> E <b>|</b> F <b>|</b> G <b>|</b> H <b>|</b> I <b>|</b> J <b>|</b> K <b>|</b> L <b>|</b> M <b>|</b> N <b>|</b> O <b>|</b> P <b>|</b> Q <b>|</b> R <b>|</b> S <b>|</b> T <b>|</b> U <b>|</b> V <b>|</b> W <b>|</b> X <b>|</b> Y <b>|</b> Z
&lt;AlphaNum&gt; <b>-&gt;</b> 0 <b>|</b> 1 <b>|</b> 2 <b>|</b> 3 <b>|</b> 4 <b>|</b> 5 <b>|</b> 6 <b>|</b> 7 <b>|</b> 8 <b>|</b> 9
</pre>
          Beachten Sie: ich habe hier absichtlich nicht
          <code>&lt;AlphaNum&gt; *-&gt;* a *|* ... *|* z</code>
          geschrieben, weil ich in diesem Beispiel wirklich alles ausschreiben wollte und mit der
          ...-Notation
          schon wieder etwas menschen- aber nicht maschinenlesbares
          eingeführt hätte.
          Wir brauchen noch Regeln für
          <code>&lt;User&gt;</code>. Dies ist ein nichtleerer String aus
          alphanumerischen Zeichen und dem Punkt
          <code>.</code>, wobei
          der Punkt nicht am Anfang und nicht am Ende stehen darf. Also: eine nichtleere Folge von
          <i>Namensblöcken</i>, die jeweils durch
          <code>.</code>
          separiert sind,
          wobei ein Namensblock eine nichtleere Folge alphanumerischer Zeichen ist.
<pre class="container">
&lt;User&gt; <b>-&gt;</b>&lt;NameBlock&gt; <b>|</b>&lt;NameBlock&gt; .&lt;User&gt;
&lt;NameBlock&gt; <b>-&gt;</b>&lt;AlphaNum&gt; <b>|</b>&lt;AlphaNum&gt;&lt;NameBlock&gt;
</pre>
          Nun haben wir unser Emailformat vollständig beschrieben. Das gesamte Regelwerk sehen Sie hier
          noch
          einmal im Ganzen:
<pre
  id="email-context-free-grammar"
  class="container listing"
>
<code>&lt;EmailAddress&gt;    *-&gt;* &lt;User&gt; @&lt;Domain&gt;</code>
<code>&lt;Domain&gt;          *-&gt;* &lt;Label&gt; .&lt;Label&gt; *|*&lt;Label&gt; .&lt;Domain&gt;</code>
<code>&lt;User&gt;            *-&gt;* &lt;NameBlock&gt; *|*&lt;NameBlock&gt; .&lt;User&gt;</code>
<code>&lt;NameBlock&gt;       *-&gt;* &lt;AlphaNum&gt; *|*&lt;AlphaNum&gt;&lt;NameBlock&gt;</code>
<code>&lt;Label&gt;           *-&gt;* &lt;AlphaNumOrDash&gt; *|*&lt;AlphaNumOrDash&gt;&lt;Label&gt;</code>
<code>&lt;AlphaNumOrDash&gt;  *-&gt;* &lt;AlphaNum&gt; *|* -</code> 
<code>&lt;AlphaNum&gt;        *-&gt;* a *|* b *|* c *|* d *|* e *|* f *|* g *|* h *|* i *|* j *|* k *|* l *|* m *|* n *|* o *|* p *|* q *|* r *|* s *|* t *|* u *|* v *|* w *|* x *|* y *|* z</code>
<code>&lt;AlphaNum&gt;        *-&gt;* A *|* B *|* C *|* D *|* E *|* F *|* G *|* H *|* I *|* J *|* K *|* L *|* M *|* N *|* O *|* P *|* Q *|* R *|* S *|* T *|* U *|* V *|* W *|* X *|* Y *|* Z</code>
</pre>
          <Topic>
            Ein Beispiel einer formalen Grammatik und einer Ableitung
          </Topic>
          Was Sie hier sehen, nennt man eine
          <i>formale Grammatik</i>. Ihre Bestandteile sind:
          <ul>
            <li>
              Das Alphabet $\Sigma$ aller verwendeten Zeichen, in unserem
              Fall also $\Sigma = \{a,\dots,z,A,\dots,Z,.,-,@\}$. Wir nennen $\Sigma$ die Menge
              der
              <i>terminalen Symbole</i>.
            </li>
            <li>
              Eine Menge $N$ abstrakter Symbole, hier
              $$
              N = \{\texttt{&lt;EmailAddress&gt;,&lt;Domain&gt;,
              &lt;User&gt;,&lt;NameBlock&gt;,&lt;Label&gt;,&lt;AlphaNumOrDash&gt;,&lt;AlphaNum&gt;}
              \} \ .
              $$
              Diese Menge nennen wir die
              <i>nichtterminalen Symbole</i>. Wir verlangen, dass $N \cap
              \Sigma
              = \emptyset$ gilt; ein Symbol kann also
              nicht gleichzeitig Terminalsymbol und Nichtterminalsymbol sein.
            </li>
            <li>
              Eine Menge $P$ von Regeln, auch
              <i>Produktionen</i>
              genannt, wobei jede Regel die Form
              $X \rightarrow \alpha$ hat, wobei $\alpha$ eine beliebig lange endliche Folge von
              Symbolen
              in $\Sigma \cup N$ ist.
            </li>
            <li>
              Ein Startsymbol $S \in N$, das angibt, wo wir mit unserer Ableitung beginnen sollen. Im
              obigen
              Beispiel
              sind wir ja an Emailadressen interessiert, also ist
              <code>&lt;EmailAddress&gt;</code>
              das
              Startsymbol.
            </li>
          </ul>
          Wenn wir nun so eine Grammatik gegeben haben, können wir Wörter
          <i>ableiten</i>; das heißt,
          wir beginnen mit dem
          Startsymbol und ersetzen in jedem Schritt ein nichtterminales Symbol durch die rechte Seite
          einer entsprechenden Regel.
          Dieser Vorgang ist nicht eindeutig und lässt mehrere Möglichkeiten offen; das ist auch gut so,
          denn es soll ja mehr als
          eine Email-Adresse geben. Hier ist ein Beispiel für eine Ableitung basierend auf der obigen
          Grammatik:
<pre class="container">
<code>&lt;EmailAddress&gt;  *-&gt;*&lt;User&gt;@&lt;Domain&gt;</code>
 <code>*-&gt;*&lt;NameBlock&gt;.&lt;User&gt;@&lt;Domain&gt;</code> 
 <code>*-&gt;*&lt;NameBlock&gt;.&lt;NameBlock&gt;@&lt;Domain&gt;</code> 
 <code>*-&gt;*&lt;NameBlock&gt;.&lt;NameBlock&gt;@&lt;Label&gt;.&lt;Domain&gt;</code> 
 <code>*-&gt;*&lt;NameBlock&gt;.&lt;NameBlock&gt;@&lt;Label&gt;.&lt;Label&gt;.&lt;Label&gt;</code> 
 <code>*-&gt;*&lt;AlphaNum&gt;.&lt;NameBlock&gt;@&lt;Label&gt;.&lt;Label&gt;.&lt;Label&gt;</code> 
 <code>*-&gt;*&lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;Label&gt;.&lt;Label&gt;.&lt;Label&gt;</code> 
 <code>*-&gt;*&lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;Label&gt;.&lt;Label&gt;</code> 
 <code>*-&gt;*&lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;Label&gt;</code> 
 <code>*-&gt;*&lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;&lt;Label&gt;</code> 
 <code>*-&gt;*&lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;&lt;AlphaNumOrDash&gt;</code> 
 <code>*-&gt;* d.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;&lt;AlphaNumOrDash&gt;</code> 
 <code>*-&gt;* d.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;e</code>
 <code>*-&gt;* d.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.de</code>
 <code>*-&gt;* d.s@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.de</code>
 <code>*-&gt;* d.s@&lt;AlphaNumOrDash&gt;.b.de</code>
 <code>*-&gt;* d.s@a.b.de</code> 
</pre>
          Nach dem gleichen Schema könnten wir
          <code>d.s.@-.-.--</code>
          ableiten, was
          darauf schließen lässt, dass unsere Grammatik nicht wirklich das
          tut, was wir beabsichtigen, dass sie nämlich
          <i>zu viele</i>
          Emailadressen
          herleitet, auch solche, die wir nicht als zulässige Adressen gelten lassen wollen.
          <Statement title="*Übungsaufgabe*">
            Formulieren Sie weitere Regeln, um unsinnige Domainnamen wie
            <code>-.-.--</code>
            zu verbieten. Wie müssen Sie die obige Grammatik ändern?
          </Statement>
          <h1>
            Terminologie, formale Definitionen und Beispiele
          </h1>
          Im letzten Abschnitt haben wir die Regeln für die Bildung syntaktisch korrekter
          Emailadressen formalisiert. Zwar unvollständig, doch hoffe ich, dass das allgemeine
          Schema klar geworden ist. Wir werden nun alles formaler und abstrakter definieren.
          <Topic>
            Alphabet
          </Topic>
          Wenn wir über formale Sprachen reden, so liegt immer eine (endliche) Menge von
          Symbolen zugrunde, das Alphabet $\Sigma$. Im Emailadressen-Beispiel war (\Sigma) recht groß:
          die 52 Buchstaben; 10 Ziffern; die Zeichen
          <code>@ . -</code>
          . Für Java-Programme oder
          andere Programmiersprachen kämen
          noch weitere Zeichen hinzu, zum Beispiel
          <code>+ - / \ { }</code>
          und so weiter;
          wenn wir alle Unicode-Zeichen miteinschließen, landen wir im Millionenbereich.
          In den theoretischen Beispielen, die in diesem Kurs folgen werden, ist das Alphabet fast immer
          viel kleiner: typische Alphabete zum Beispiel sind $\{0,1\}$ , $\{a,b,c,d\}$ oder auch
          $\{1\}$, ein Alphabet mit nur einem Zeichen.
          Für ein Alphabet $\Sigma$ bezeichnen wir mit $\Sigma^*$ die Menge aller
          endlichen Strings über diesem Alphabet; das schließt den
          <i>leeren String</i>
          mit ein,
          den wir mit $\epsilon$ bezeichnen. So ist beispielsweise
          $$
          \{a,b\}^* = \{\epsilon, a, b, aa, ab, ba, bb, aaa, aab, aba, ...\}
          $$
          Ein Element $x \in \Sigma^*$, also einen endlichen String aus $\Sigma$-Symbolen,
          bezeichnen wir als
          <i>Wort über $\Sigma$</i>.
          Mit $\Sigma^+$ bezeichnen wir die Menge aller nichtleeren Strings, also
          $\Sigma^+ = \Sigma^* \setminus \{\epsilon\}$.
          <Topic>
            Sprachen
          </Topic>
          Eine Teilmenge $L \subseteq \Sigma$ bezeichnen wir in diesem Kontext als
          <i>Sprache</i>
          und
          kürzen Sie oft mit $L$ ab, was für
          <i>language</i>
          steht. Beispiele für Sprachen wären
          <ol>
            <li>
              Die Sprache aller syntaktisch korrekten Emailadressen.
            </li>
            <li>
              Die Sprache aller Java-Programme, die ohne Fehlermeldung kompilieren
            </li>
            <li>
              Die Sprache aller Java-Programme, die kompilieren, dann aber mit einem Laufzeitfehler
              abbrechen.
            </li>
            <li>
              Die Sprache aller Java-Programme, die kompilieren und nicht mit einem Laufzeitfehler
              abbrechen.
            </li>
            <li>
              Die Sprache aller Wörter über $\{a,b\}$, die gleich viele $a$'s wie $b$'s enthalten.
            </li>
            <li>
              Die Sprache aller Palindrome über $\{a,b,c,d\}$, also Wörter, die von vorne wie hinten
              gelesen gleich aussehen.
            </li>
          </ol>
          Wir wollen herausfinden, welche Arten von Sprachen wir mit den im letzten Abschnitt eingeführen
          Regelwerk
          aus Ableitungen beschreiben können. Für die gerade aufgelisteten sechs Sprachen lautet die
          Antwort
          <ol>
            <li>
              Ja, können wir.
            </li>
            <li>
              Ja, wenn wir leicht komplexere Ableitungsregeln erlauben.
            </li>
            <li>
              Ja, wenn wir leicht komplexere Ableitungsregeln erlaubten.
            </li>
            <li>
              Nein, können wir nicht.
            </li>
            <li>
              Ja, können wir.
            </li>
            <li>
              Ja, können wir.
            </li>
          </ol>
          <Topic>
            Grammatiken
          </Topic>
          <Statement title="*Definition*">
            <b>(Kontextfreie Grammatik).</b>
            Eine
            <i>kontextfreie Grammatik</i>
            besteht aus
            <ol>
              <li>
                einem endlichen Alphabet $\Sigma$, den
                <i>terminalen Symbolen</i>;
              </li>
              <li>
                einer dazu disjunkten endlichen Menge $N$, genannt die
                <i>nichtterminalen
                  Symbole</i>;
              </li>
              <li>
                einer endlichen Menge $P$ von
                <i>Produktionsregeln</i>
                der Form
                $X \rightarrow \alpha$ mit $X \in N$ und $\alpha \in (\Sigma \cup \N)^*$;
                formal also $P \subseteq N \times (\Sigma \cup \N)^*$.
              </li>
              <li>
                einem Startsymbol $S \in N$.
              </li>
            </ol>
            Die Grammatik $G$ ist also ein 4-Tupel $(\Sigma, N, P, S)$.
          </Statement>
          Woher der Name
          <i>kontextfrei</i>
          kommt, werden Sie hoffentlich verstehen, wenn wir
          <i>Ableitungen</i>
          definiert haben.
          Die Tradition will es, dass wir für die terminalen Symbole
          Zahlen oder lateinsiche Kleinbuchstaben und für die nichtterminalen Symbole
          lateinische Großbuchstaben verwenden.
          Dies ist eine Konvention, die hilfreich ist, solange wir auf abstrakt-theoretischer
          Ebene über formale Grammatiken sprechen; wenn Sie z.B. eine Grammatik
          für Java erstellen wollen, dann wird $\Sigma$ natürlich auch Großbuchstaben enthalten.
          <Statement title="*Beispiel*">
            Wir betrachten die Grammatik $G = (\{a,b\}, \{S, A, B\}, P, S)$ mit den Produktionsregeln
            $$
            \begin{align*}
            S&amp;\rightarrow A B \\
            A&amp;\rightarrow \epsilon \ | \ a A \\
            B&amp;\rightarrow \epsilon \ | \ b B \ . \\
            \end{align*}
            $$
            Formal sind die Produktionsregeln $P$ eine Teilmenge von $N \times (\Sigma \cup \N)^*$,
            also
            $$
            P = \{ (S, AB), (A, \epsilon), (A, aA), (B, \epsilon), (B, bB) \} \ .
            $$
            Für konkrete Beispiele wie die gerade betrachtete Grammatik jedoch verwenden wir einfach die
            Pfeilschreibweise $S \rightarrow AB, \dots$. Hier ist
            eine
            <i>Ableitung</i>
            basierend auf der Grammatik:
            $$
            \begin{align*}
            S \Rightarrow AB \Rightarrow aAB \Rightarrow aAbB \Rightarrow aAbbB
            \Rightarrow aAbb \Rightarrow abb \ .
            \end{align*}
            $$
            In jedem Schritt wählen wir ein Nichtterminal aus, zum Beispiel im zweiten Schritt $A$,
            und wenden eine Regel an, zum Beispiel $A \rightarrow aA$. Dadurch
            wird $AB$ zu $aAB$.
            Wir setzen diese Ableitungsschritte so lange fort, bis nur noch terminale Symbole
            übrigbleiben. Dann hat sich ein Wort $\alpha \in \Sigma^*$ ergeben.
          </Statement>
          <Statement title="*Definition*">
            Gegeben sei eine kontextfreie Grammatik $G = (\Sigma, N, P, S)$.
            Ein String $\alpha \in (\Sigma \cup N)^*$ heißt
            <i>Wortform</i>
            (im Gegensatz
            zu einem Wort $x \in \Sigma^*)$.
            Für zwei Wortformen $\alpha , \beta$ schreiben wir
            $$
            \alpha \Rightarrow \beta
            $$
            wenn wir $\alpha$ zu $\beta$ machen können, indem wir ein nichtterminales
            Symbol $X$ in $\alpha$ durch die rechte Seite $X \rightarrow \gamma$ ersetzen können.
            Formal gesprochen, wenn wir $\alpha = \alpha_1 X \alpha_2$ und $\beta = \beta_1 \gamma
            \beta_2$
            mit Wortformen $\alpha_1, \alpha_2, \beta_1, \gamma, \beta_2$ und einem Nichtterminal
            $X$ schreiben können, so dass $X \rightarrow \gamma$ eine Produktionsregel in $P$ ist.
            Wenn wir $\alpha = \beta$ "vorlesen", dann sagen wir
            <i>$\beta$ kann aus $\alpha$ in
              einem Schritt abgeleitet werden</i>.
            Wenn $\beta$ aus $\alpha$ in mehreren (im Extremfall null) Schritten
            abgeleitet werden kann, so schreiben wir $\alpha \Rightarrow^* \beta$.
            Formal bedeutet $\alpha \Rightarrow^* \beta$, dass es ein $k \geq 0$ gibt
            und "Zwischenwortformen" $\alpha_0, \alpha_1, \dots, \alpha_k$ mit
            $\alpha = \alpha_0$ und $\alpha_k = \beta$, sodass
            $\alpha_i \Rightarrow \alpha_{i+1}$ für alle $i = 0, 1, \dots, k-1$ gilt.
            Dies schließt den "trivialen" Fall $k=0$ mit ein, in welchem $\alpha = \beta$ gilt.
          </Statement>
          Nochmals: wenn $\alpha$ die Form $\alpha_1 X \alpha_2$ hat, dann dürfen Sie
          das Nichtterminal $X$ durch die rechte Seite einer Produktionsregel $X \rightarrow \gamma$
          ersetzen; Sie dürfen das unabhängig von dem
          <i>Kontext</i>, in welchem $X$ in
          der Wortform $\alpha$ vorkommt. Daher rührt der Name
          <i>kontextfreie Grammatik</i>.
          Beachten Sie, dass $P$ per Definition eine
          <i>endliche Menge</i>
          von Regeln
          sein muss, dass jedoch $\Rightarrow$ im Allgemeinen unendlich ist. Bereits
          für unsere einfache Grammatik mit den Produktionsregeln
          $$
          \begin{align*}
          S&amp;\rightarrow A B \\
          A&amp;\rightarrow \epsilon \ | \ a A \\
          B&amp;\rightarrow \epsilon \ | \ b B \ . \\
          \end{align*}
          $$
          haben wir beispielsweise
          $$
          \begin{align*}
          A&amp;\rightarrow aA \\
          aA&amp;\rightarrow aaA \\
          aaA&amp;\rightarrow aaaA \\
          \dots
          \end{align*}
          $$
          und sehen, dass die Menge aller Paare $\alpha \Rightarrow \beta$ unendlich ist.
          <Statement title="*Definition*">
            <b>(Die von einer Grammatik erzeugte Sprache).</b>
            Sei $G = (\Sigma, N, P, S)$ eine kontextfreie Grammatik. Die von $G$ erzeugte Sprache
            $L(G)$ ist die Menge aller Wörter, die vom Startsymbol $S$ abgeleitet werden können, also
            $$
            \begin{align*}
            L(G) := \{x \in \Sigma^* \ | \ S \Rightarrow^* x\} \ .
            \end{align*}
            $$
            Wenn es zu einer Sprache $L \subseteq \Sigma^*$ eine kontextfreie Grammatik $G$ mit
            $L(G) = L$ gibt, so nennen wir $L$ eine
            <i>kontextfreie Sprache</i>.
          </Statement>
          Beachten Sie, dass in dem obigen Beispiel die Wortform
          $aaAB$ zwar aus $S$ abgeleitet werden kann, allerdings kein
          <i>Wort</i>
          ist,
          da es noch nichtterminale Symbole enthält. Es gilt also $aaAB \not \in L(G)$.
          Oft können wir $L(G)$ kompakt mit natürlicher Sprache beschreiben:
        </div>
        <Statement title="*Beispiel*">
          Sei $G$ die zuletzt betrachtete Grammatik. Dann ist $L(G)$ die
          Menge aller Wörter der Form $a^* b^*$, also Wörter, in denen auf beliebig viele
          $a$'s beliebig viele $b$'s folgen.
        </Statement>
        Wir betrachten nun einige weitere Beispiele
        <Statement title="*Beispiel*">
          Wir betrachten die Grammatik $G_2 = (\{a,b\}, \{S\}, P, S)$ mit den Produktionsregeln
          $$
          \begin{align}
          S&amp;\rightarrow aSbS \\
          S&amp;\rightarrow bSaS \\
          S&amp;\rightarrow \epsilon \ .
          \end{align}
          $$
          Hier sind mögliche Ableitungen des Wortes $abab$. Zur Verdeutlichung
          schreiben wir über den Pfeil $\Rightarrow$ die Nummer der Regel, die
          wir angewendet haben:
          $$
          \begin{align*}
          S&amp;\stackrel{(1)}{\Rightarrow} aSbS
          \stackrel{(1)}{\Rightarrow} aSbaSbS
          \stackrel{(3)}{\Rightarrow} aSbaSb
          \stackrel{(3)}{\Rightarrow} abaSb
          \stackrel{(3)}{\Rightarrow} abab \\
          S&amp;\stackrel{(1)}{\Rightarrow} aSbS
          \stackrel{(3)}{\Rightarrow} abS
          \stackrel{(1)}{\Rightarrow} abaSbS
          \stackrel{(3)}{\Rightarrow} ababS
          \stackrel{(3)}{\Rightarrow} abab \ .
          \end{align*}
          $$
          Wir sehen also: das gleiche Wort kann mehrere Ableitungen haben.
          Da die Ersetzungsregeln
          <i>kontextfrei</i>
          sind, spielt es keine Rolle, in welcher
          Reihenfolge wir nichtterminale Symbole ersetzen. Wenn Sie scharf hinschauen,
          werden Sie erkennen, dass die beiden Ableitungen "irgendwie gleich" sind, dass nur
          die Ableitungen in anderer Reihenfolge durchgeführt worden sind. Ich werde
          das in einem späteren Kapitel formal definieren, was ich mit damit meine.
          Um Ordnung in das Chaos zu bringen, könnten wir uns zum Beispiel einigen,
          dass man immer das am weitesten links stehende Nichtterminal ersetzen muss.
          Das nennt man eine
          <i>Linksableitung</i>. Dies ist nicht wirklich eine
          Einschränkung, da die Ersetzungsreihenfolge keine Rolle spielt.
          Wir sehen, dass die zweite Ableitung des Wortes $abab$ oben eine
          Linksableitung ist; zusammen mit der Beschriftung
          $\stackrel{(i)}{\Rightarrow}$, die die Nummer der angewendeten Regel
          angibt, ist eindeutig, wie wir von $S$ zum abgeleiteten Wort gekommen sind.
          Betrachten Sie nun eine weitere Linksableitung $S \Rightarrow^* abab$:
          $$
          \begin{align*}
          S&amp;\stackrel{(1)}{\Rightarrow} aSbS
          \stackrel{(2)}{\Rightarrow} abSaSbS
          \stackrel{(3)}{\Rightarrow} abaSbS
          \stackrel{(3)}{\Rightarrow} ababS
          \stackrel{(3)}{\Rightarrow} abab
          \end{align*}
          $$
          Sehen Sie, dass diese Ableitung
          <i>qualitativ</i>
          anders ist, da
          wir hier auch die Regel $S \rightarrow bSaS$ angewendet haben? Um die
          Struktur der Ableitung zu verdeutlichen, könnten wir
          die ersten beiden Ableitungen mit
          Wort $S \Rightarrow^* (ab)(ab)$ bezeichnen und die dritte mit Wort $S \Rightarrow^* a(ba)b$.
        </Statement>
        <Topic>
          Ziele der Theorie der formalen Sprachen
        </Topic>
        Ganz allgemein gesagt wollen wir lernen, wie wir Sprachen formal beschreiben können;
        wie wir, gegeben eine Grammatik $G$ und ein Zielwort $x$, eine Ableitung
        $G \Rightarrow^* x$ finden können. Anhand der Ableitungssequenz können wir
        dann oft auf die logische Struktur von $x$ schließen. Handelt es sich bei
        $G$ zum Beispiel um eine Grammatik für die Programmiersprache Java,
        so wäre ein Ziel, aus der Ableitungssequenz $G \Rightarrow^* x$ die Struktur
        des Programms $x$, also Klassenstruktur, Methoden, etc., ablesen zu können und schlussendlich
        das Programm in ausführbaren Maschinencode kompilieren zu können.
        <Statement title="*Algorithmisches Problem: Parsing*">
          Gegeben eine (kontextfreie) Grammatik $G$ und ein Zielwort $x$,
          finde eine Ableitung $G \Rightarrow^* x$, falls es so eine gibt.
          Für einen String $x$ eine Ableitung zu finden bezeichnen wir als
          <i>parsen</i>,
          das zugehörige Hauptwort als
          <i>Parsing</i>.
        </Statement>
        <b>Die gute Nachricht:</b>
        Die gute Nachricht: wir kennen Algorithmen, die dieses
        Problem im effizient lösen, wenn wir den "theoretischen" Effizienzbegriff
        zugrund legen.
        <b>Die schlechte Nachricht:</b>
        wir kennen keinen Algorithmus,
        der das Parsing kontextfreier Sprachen in seiner ganzen Allgemeinheit
        in
        <i>linearer Zeit</i>
        erledigt, dessen Laufzeit also proportional zur Länge des Zielwortes
        $x$ ist. Dies ist aber, was wir in der Praxis, zum Beispiel bei Compilern, erwarten.
        <b>Die gute Nachricht:</b>
        in fast allen praktisch relevanten Fällen haben
        wir es mit Grammatiken zu tun, die Parsing in linearer Zeit ermöglichen.
        Und wenn wir Programmiersprachen, Datenformate etc. entwerfen, haben wir es ja in der Hand,
        Sprache und Grammatik so anzulegen, dass effizientes Parsen möglich ist. 
        Im nächsten Kapitel lernen wir eine stark eingeschränkte, aber dennoch sehr wichtige Klasse
        kontextfreier Grammatik kennen, die allesamt ein sehr effizientes Parsing
        erlauben: die sogenannten
        <i>regulären</i>
        Grammatiken.
      </div>
    </div>
  </div>
</section>
</body>
