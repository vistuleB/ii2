<!DOCTYPE html>
<html>
<head>
  
        <link rel="icon" href="data:,">
        
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        
   <title></title>
        

   <meta name="viewport" content="width=device-width, initial-scale=1">
        
   <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
        
   <link rel="stylesheet" type="text/css" href="../lecture-notes.css" />
        
   <link rel="stylesheet" type="text/css" href="../TI.css" />
        
   <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        
 </script>
        
   <script type="text/javascript" src="../mathjax_setup.js"></script>
        
   <script type="text/javascript" src="../carousel.js"></script>
        
   <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>
      <section
        count={27}
        title_gr="Übungsaufgaben"
        title_en="exercises"
        number={4.7}
        counter="DefCtr"
        counter="ExoCtr"
        path="/lecture-notes27.tsx">
        <div id="link-to-toc">
          <a href="../vorlesungsskript.html">
            Inhaltsverzeichnis
          </a>
          <a href="04-06-limitations-of-regular-grammars.html">
            &lt;&lt; Kapitel 4.6
          </a>
        </div>
        <div
          id="link-to-overview"
          style="text-align: end">
          <a href="/">
            zur Kursübersicht
          </a>
          <a href="05-00-context-free-languages.html">
            Kapitel 5.0 &gt;&gt;
          </a>
        </div>
        <div id="rightSideWrapper">
          <div class="content">
            <div class="chapter">
              <div class="subChapter">
                <h1 class="hidden-title">
                  <span class="subChapterTitle">
                    4.7 
                    Übungsaufgaben
                  </span>
                </h1>
                <h3>
                  Reguläre Sprachen und primitive Rekursion
                </h3>
                <div class="well well-lg numbered-exercise container">
                  <p>
                    <span class="numbered-title">
                      Übungsaufgabe
                      <NumberedTitle>
                        &ensp;4.7.1 
                      </NumberedTitle>
                    </span>
                    Sei \(\Sigma = \{\sigma_1, \sigma_2, \dots, \sigma_k\}\) ein endliches Alphabet. Wir
                    können jedes Zeichen \(\sigma_i \in \Sigma\) als
                    natürliche Zahl \(i\) codieren. Ein Wort \(\alpha \in \Sigma^*\)
                    wird somit zu einer Folge \((a_1, a_2, \dots, a_n) \in \N^*\), was
                    wir wiederum mit den Methoden aus
                    <a href="02-02-examples-of-equipotent-sets.html">
                      &ensp;Kapitel 2.2 
                    </a>
                    als 
                    <i>
                      eine
                    </i>
                     natürliche Zahl \(\bar{\alpha}\) codieren können.
                    Mittels dieser Codierung wird eine Sprache \(L \subseteq \Sigma^*\)
                    zu einer Funktion
                  </p>
                  $$\begin{align*}
                  f_L : \N&amp;\rightarrow \{0,1\} \\
                  a&amp;\mapsto
                  \begin{cases}
                  1&amp;\textnormal{ if $\exists \alpha \in L$ with $\bar{\alpha} = a$} \\
                  0&amp;\textnormal{ else.}
                  \end{cases}
                  \end{align*}$$
                  <p>
                    Sei \(L\) eine reguläre Sprache. Zeigen Sie, dass \(f_L\) primitiv rekursiv ist!
                  </p>
                </div>
                <h3>
                  Reguläre Sprachen und Schaltkreise
                </h3>
                <p>
                  Wir können jedes Zeichen \(\sigma \in \Sigma\) als
                  Bitstring \(x_{\sigma} \in \cube^k\) codieren, mit \(k = \ceil{\log_2|\Sigma|}\), und
                  damit jedes \(\alpha = (a_1, \dots, a_n) \in \Sigma^*\) als \(x_a \in \cube^*\) mit \(nk\) Bits.
                  Smit wird jede Sprache \(L \subseteq \Sigma^*\) zu einer Funktion
                  \(f_L : \cube^* \rightarrow \cube\) mittels
                </p>
                $$\begin{align*}
                f_L : \cube^*&amp;\rightarrow \cube \\
                y&amp;\mapsto
                \begin{cases}
                1&amp;\textnormal{if $\exists \alpha \in L: x_\alpha = y$} \\
                0&amp;\textnormal{else.}
                \end{cases}
                \end{align*}$$
                <p>
                  Für festes \(n\) definieren wir \(f_L^n : \cube^n \rightarrow \cube\) als die
                  Restriktion von \(f_L\) auf \(\cube\), also die Funktion, die nur \(n\)-Bit-Strings
                  als Input akzeptiert.
                </p>
                <p>
                  Zeigen Sie: wenn \(L \subseteq \Sigma^*\) regulär ist, dann gibt es für
                  jedes \(n\) einen Schaltkreis \(C\) mit \(O(n)\) Gates, der \(f_L\) berechnet.
                </p>
              </div>
              <div class="well well-lg numbered-exercise container">
                <p>
                  <span class="numbered-title">
                    Übungsaufgabe
                    <NumberedTitle>
                      &ensp;4.7.2 
                    </NumberedTitle>
                  </span>
                  Verbessern Sie die obige Konstruktion: Ihr Schaltkreis \(C\) sollte nun
                  Tiefe \(O(\log(n))\) haben und vorzugsweise immer noch \(O(n)\) Gates.
                </p>
              </div>
              <div class="well well-lg numbered-exercise container">
                <p>
                  <span class="numbered-title">
                    Übungsaufgabe
                    <NumberedTitle>
                      &ensp;4.7.3 
                    </NumberedTitle>
                  </span>
                  &ensp;
                  <b>
                    (Challenge).
                  </b>
                  Betrachten wir eine Variante des endlichen Automaten, bei der
                  der Automat 
                  <i>
                    zurückspulen
                  </i>
                   kann. Der Automat hat also
                  einen "Lesekopf", mit dem er auf einem Zeichen des Eingabewortes steht
                  (anfangs auf dem ersten). In jedem Schritt kann er nach rechts oder links
                  wechseln. Es gibt zwei spezielle Zeichen, die markieren, wo das
                  Wort aufhört: \(\lt\) und \(\gt\). Die Zustandsübergangsfunktion ist also
                </p>
                $$\begin{align*}
                \delta: Q \times (\Sigma \cup \{\lt, \gt\}) \rightarrow Q \times \{L, R\} \ .
                \end{align*}$$
                <p>
                  Wenn z.B. \(\delta(q, x) = (r, L)\) ist, dann heißt das: 
                  <i>
                    wenn Du im
                    Zustand \(q\) bist und der Lesekopf ein \(x\) liest, dann wechsle in den
                    Zustand \(r\) und gehe nach links.
                  </i>
                    
                </p>
                <p>
                  Der Automat hat genau einen akzeptierenden und einen ablehnenden Zustand.
                  Wenn ein solcher Zustand erreicht wird, hält der Automat an und gibt
                  1 bzw. 0 aus.
                  Die von so einem Automaten \(M\) akzeptierte Sprache \(L(M)\) ist dann definiert als
                  die Menge aller Wörter \(\alpha\), die \(M\) in einen akzeptierenden
                  Zustand bringen. Beachten Sie, dass \(M\) möglicherweise in eine Endlosschleife
                  geraten kann. In diesem Falle ist \(\alpha\) 
                  <i>
                    kein
                  </i>
                   Wort in \(L(M)\).
                </p>
                <p>
                  Zeigen Sie, dass \(L(M)\) eine reguläre Sprache ist. Dass man also aus \(M\)
                  einen neuen Automaten \(M'\) bauen kann, der nur nach rechts laufen kann.
                </p>
              </div>
              <div class="well well-lg numbered-exercise container">
                <p>
                  <span class="numbered-title">
                    Übungsaufgabe
                    <NumberedTitle>
                      &ensp;4.7.4 
                    </NumberedTitle>
                  </span>
                  Sei \(\Sigma = \{1,2, \dots, k\}\) und \(L\) die Sprache aller
                  Wörter, in denen mindestens ein Zeichen fehlt, also
                </p>
                $$\begin{align*}
                L = \bigcup_{i=1}^k (\Sigma \setminus \{i\})^*
                \end{align*}$$
                <p>
                  Zeigen Sie, dass ein endlicher Automat für \(L\) mindestens \(2^k\) Zustände braucht.
                </p>
              </div>
              <div class="well well-lg numbered-exercise container">
                <p>
                  <span class="numbered-title">
                    Übungsaufgabe
                    <NumberedTitle>
                      &ensp;4.7.5 
                    </NumberedTitle>
                  </span>
                  Schreiben Sie eine reguläre Grammatik für \(L\) mit höchstens \(k+1\) Nichtterminalen.
                </p>
              </div>
              <div class="well well-lg numbered-exercise container">
                <p>
                  <span class="numbered-title">
                    Übungsaufgabe
                    <NumberedTitle>
                      &ensp;4.7.6 
                    </NumberedTitle>
                  </span>
                  &ensp;
                  <b>
                    (Challange.)
                  </b>
                  Sei \(L\) die Sprache aus der vorherigen Aufgabe und
                  \(\bar{L} = \Sigma^* \setminus L\) ihr Komplement. \(\bar{L}\) ist also
                  die Sprache aller Wörter, in denen jedes Zeichen aus \(\Sigma\) mindestens
                  einmal vorkommt.
                </p>
                <p>
                  Zeigen Sie, dass jede reguläre Grammatik für \(\bar{L}\) mindestens \(2^k\)
                  Nichtterminale benötigt.
                </p>
              </div>
            </div>
          </div>
        </div>
      </section>
    </body>
