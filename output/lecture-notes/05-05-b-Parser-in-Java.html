<!DOCTYPE html>
<html>
<head>
      <link rel="icon" href="data:,">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="../lecture-notes.css" />
    <link rel="stylesheet" type="text/css" href="../TI.css" />
    <link rel="stylesheet" type="text/css" href="../tooltip-3003.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script type="text/javascript" src="../numbered-title.js"></script>
    <script type="text/javascript" src="../mathjax_setup.js"></script>
    <script type="text/javascript" src="../carousel.js"></script>
    <script type="text/javascript" src="../sendCmdTo3003.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>
<section
  count="34"
  .="BookLevelSectionCounter 34"
  title_gr="Parser in Java implementieren"
  title_en="b Parser in Java"
  number="5.5"
  counter="DefCtr"
  counter="ExoCtr"
  path="/lecture-notes34"
>
  <div id="link-to-toc">
    <a href="../vorlesungsskript.html">Inhaltsverzeichnis</a><a href="05-05-a-LR-parsing-by-hand.html">&lt;&lt; Kapitel 5.5</a>
  </div>
  <div
    id="link-to-overview"
    style="text-align: end"
  >
    <a href="/">zur Kursübersicht</a><a href="05-05-c-LR-grammars.html">Kapitel 5.5 &gt;&gt;</a>
  </div>
  <div id="rightSideWrapper">
    <div class="content">
      <div class="chapter">
        <div class="subChapter">
          <h1 class="hidden-title">
            <span class="subChapterTitle">::::ChapterCtr.6
              Einen Parser in Java implementieren</span>
          </h1>
          <div class="alert-info well">
            Den vollständigen Quelltext, den wir in der Vorlesung geschrieben haben,
            finden Sie in der Datei
            <a href="../code/parsing/arithmetic-in-class/ArithmeticGrammar.java">ArithmeticGrammar.java</a>.
          </div>
          Ich möchte nun eine kontextfreie Grammatik für arithmetische Ausdrücke der
          Form
          <code>((31+402)*83)</code>
          entwerfen. Der Einfachheit halber bestehe ich
          auf strenger Klammerung, so wäre
          <code>(2*(1+2+3))</code>
          zum Beispiel nicht erlaubt.
          Unsere Grammatik soll allgemeine Dezimalzahlen darstellen können.
          Das Alphabet ist somit
          $\Sigma = \{\texttt{0},\texttt{1},\texttt{2},\texttt{3},\texttt{4},
          \texttt{5},\texttt{6},\texttt{7},\texttt{8},\texttt{9},
          \texttt{+},\texttt{*},\texttt{(},\texttt{)}\}$.
          Die Produktionsregeln sind:
          $$
          \begin{align*}
          E&amp;\rightarrow N \tag{JustNumber} \\
          E&amp;\rightarrow \texttt{(}E \texttt{+} E\texttt{)} \tag{Sum} \\
          E&amp;\rightarrow \texttt{(}E \texttt{*} E\texttt{)} \tag{Product}\\
          N&amp;\rightarrow D \tag{SingleDigit} \\
          N&amp;\rightarrow ND \tag{NumberDigit} \\
          D&amp;\rightarrow \texttt{0}\ | \ \texttt{1}\ | \ \texttt{2}\ | \ \texttt{3}\ | \ \texttt{4}\ | \
          \texttt{5}\ | \ \texttt{6}\ | \ \texttt{7}\ | \ \texttt{8}\ | \ \texttt{9}
          \end{align*}
          $$
          Die Nichtterminale sind also $E$ (Expression), $N$ (Number) und $D$ (Digit). Wir haben auch
          den einzelnen Produktionen Namen gegeben, bis auf die der Form $D \rightarrow i$.
          Was soll nun unser Parser tun? Er soll, gegeben ein Eingabewort $w \in L$, den
          <i>Ableitungsbaum</i>
          konstruieren, für
          <code>((31+402)*83)</code>
          also
          <figure>
            <img
              style="height:20em"
              src="../img/context-free/arithmetic-syntax-tree.svg"
            >
          </figure>
          Wie wir diesen Baum in Java repräsentieren, darüber sprechen wir in einer Minute.
          Zuerst aber: wir wollen mit diesem Baum etwas Sinnvolles tun. Zum Beispiel
          <i>auswerten</i>, so dass am Ende eine Zahl rauskommt, im obigen Beispiel
          also $(31 + 402) \cdot 83 = 35939$. Oder den Ausdruck umformen von
          Infix-Notation zu Präfixnotation, also
          <code>(* (+ 31 402) 83)</code>. All dies wird sehr einfach sein, sobald wir
          den Ableitungsbaum als Datenstruktur vorliegen haben.
          <Topic>
            Eine Datenstruktur für Ableitungsbäume
          </Topic>
          Für meine Implementierung in Java erschaffe ich für jedes Nichtterminal $X$
          ein Interface
          und für jede Produktionsregel $X \rightarrow \alpha$ eine Klasse,
          die das Interface $X$ implementiert und $\alpha$ als Klassenvariable enthält.
          <ul>
            <li>
              <code>interface Expression</code>
              wird implementiert von
              <ul>
                <li>
                  <code>class Sum</code>, die als Klassenvariable
                  <code>Exrepssion e1, e2</code>
                  enthält,
                </li>
                <li>
                  <code>class Product</code>, die als Klassenvariable
                  <code>Exrepssion e1, e2</code>
                  enthält,
                </li>
                <li>
                  <code>class JustNumber</code>, die als Klassenvariable nur eine
                  <code>Number number</code>
                  enthält;
                </li>
              </ul>
            </li>
            <li>
              <code>interface Number</code>
              wird implementiert von
              <ul>
                <li>
                  <code>class MultiDigitNumber</code>, die als Klassenvariable eine
                  <code>Number</code>
                  und eine
                  <code>Digit</code>
                  erhält und
                </li>
                <li>
                  <code>class SingleDigitNumber</code>, die als Klassenvariable ein
                  <code>Digit</code>
                  enthält;
                </li>
              </ul>
            </li>
            <li>
              <code>interface Digit</code>
              wird implementiert von
              <code>class DigitOne</code>,
              <code>class DigitTwo</code>,
              <code>class DigitThree</code>,
              <code>class DigitFour</code>,
              <code>class DigitFive</code>,
              <code>class DigitSix</code>,
              <code>class DigitSeven</code>,
              <code>class DigitEight</code>
              und
              <code>class DigitNine</code>.
            </li>
          </ul>
          In unserem Anwendungsfall hat jedes Interface eine Methode
          <code>public int toInt()</code>. Interface
          <code>Expression</code>
          hat zusätzlich noch
          die Methode
          <code>String toPrefixNotation()</code>. Ich schreibe auch ein
          Über-Interface
          <code>ParseObject</code>, das alle Interfaces zusammenfasst.
          Um uns das Debugging zu erleichtern, überschreibe ich in jeder Klasse die Methode
          <code>public String toString()</code>.
        </div>
      </div>
    </div>
  </div>
</section>
</body>
