<!DOCTYPE html>
<html>
<head>
      <link rel="icon" href="data:,">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="../lecture-notes.css" />
    <link rel="stylesheet" type="text/css" href="../TI.css" />
    <link rel="stylesheet" type="text/css" href="../tooltip-3003.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script type="text/javascript" src="../numbered-title.js"></script>
    <script type="text/javascript" src="../mathjax_setup.js"></script>
    <script type="text/javascript" src="../carousel.js"></script>
    <script type="text/javascript" src="../sendCmdTo3003.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>
<section
  count="47"
  path="/lecture-notes46"
  .="BookLevelSectionCounter 47"
  counter="ExoCtr"
  counter="DefCtr"
  number="7.6"
  title_en="undecidability"
  title_gr="Haltproblem und Unentscheidbarkeit"
>
  <div
    id="link-to-toc"
  >
    <a
      href="../vorlesungsskript.html"
    >Inhaltsverzeichnis</a><a
      href="07-05-Turing-universal.html"
    >&lt;&lt; Kapitel 7.5</a>
  </div>
  <div
    style="text-align: end"
    id="link-to-overview"
  >
    <a
      href="/"
    >zur Kursübersicht</a><a
      href="07-07-Post-correspondence-problem.html"
    >Kapitel 7.7 &gt;&gt;</a>
  </div>
  <div
    id="rightSideWrapper"
  >
    <div
      class="content"
    >
      <div
        class="chapter"
      >
        <div
          class="subChapter"
        >
          <h1
            class="hidden-title"
          >
            <span
              class="subChapterTitle"
            >7.6
              Turingmaschinen, Haltproblem und Unentscheidbarkeit</span>
          </h1>
          <p>
            Im vorherigen Teilkapitel haben wir die 
            <i>universelle Turingmaschine</i>
             $U$ konstruiert, die
            eine andere Turingmaschine, deren Codierung und Inputwort sie als Input gegeben hat, simulieren
            kann.
            Technisch gesprochen: $U$ akzeptiert die Sprache
          </p>
          $$\begin{align}
          \{ c w \ | \ c = \enc(M) \textnormal{ und $M$ akzeptiert $w$} \} \ .
          \label{halting-language-old-encoding}
          \end{align}$$
          <p>
            Allerdings: wenn $M$ auf $x$ nicht terminiert, dann terminiert $U$ auf $\enc(M)x$ auch
            nicht. $U$ 
            <i>akzeptiert</i>
             die Sprache also, 
            <i>entscheidet</i>
             sie aber nicht. Wäre es
            nicht schön, eine Turingmaschine zu haben, die diese Sprache entscheidet? Dann könnten wir jede
            Turingmaschine simulieren und gleichzeitig Endlosschleifen und eventuell ganz allgemein
            "Programmierfehler" vorhersagen und abfangen. Wir werden zeigen, dass dies leider 
            <i>nicht</i>
            möglich ist. In der Literatur ist dies als die 
            <i>Unentscheidbarkeit des Halteproblems</i>
            (englisch 
            <i>undecidability of the Halting problem</i>
             bekannt).
          </p>
          <p>
            Als vorbereitenden Schritt schauen wir uns kurz die Codierungsfunktion nochmal genauer an. Wir
            bezeichnen
            mit $\tm<i>{\Sigma}$ die Menge aller Turingmaschinen mit Inputalphabet $\Sigma$. Wir hatten
              die Codierungsfunktion $\enc: \tm</i>{\Sigma} \rightarrow \Lambda^<b>$ definiert, für das
              Codierungsalphabet $\Lambda := \writelambda$. In diesem Teilkapitel wird es nötig sein, die
              Turingmaschine
              über dem Alphabet $\Sigma$ selbst zu codieren. Dies ist nicht besonders schwierig, solange
              $\Sigma$ mindestens zwei Zeichen hat. Wenn z.B. $\Sigma$ die Zeichen $0$ und $1$ enthält,
              dann können wir alle Zeichen in
              $\Lambda$ wiederum als Strings in $\Sigma^</b>$ codieren. Wir müssen hier
            nur vorsichtig sein, dass der Code 
            <i>präfixfrei</i>
             ist. Wenn wir zum Beispiel naiv
            $1$ als $1$ und $0$ als $0$ und $\texttt{#}$ als $01$ codieren, dann wissen wir nicht mehr, was
            mit dem Codewort $01$ gemeint ist. Am einfachsten geht das mit einem 
            <i>Blockcode</i>, in dem
            alle Codewörter die gleiche Länge $k$ haben, also
            $\Lambda \rightarrow \{0,1\}^k$. Mit
            $k = \ceil{\log<i>2 |\Lambda|}$ ist das kein Problem. Unsere "neue" Codierungsfunktion
              $\enc$ ist nun also $\enc: \tm</i>{\Sigma} \rightarrow \Sigma^<b>$. Wir definieren nun
              die Haltesprache $\halt \in \Sigma^</b>$:
          </p>
          $$\begin{align*}
          \halt := \{ \enc(M) w \ | \ M \textnormal{ akzeptiert } w\} \ .
          \end{align*}$$
          <p>
            Wir können die universelle Turingmaschine $U$ leicht abwandeln, dass sie $\halt$ akzeptiert;
            wir müssen nur einen Decodierungsschritt vorausschicken, der die neue Codierung $\enc(M) \in
            \Sigma^<b>$
              in unsere "alte" in $\Lambda^</b>$ übersetzt. Beachten Sie, dass das Zeichen $\texttt{;}$, das wir
            auch blockcodiert haben, uns hilft, die Grenze zwischen $\enc(M)$ und $w$ zu erkennen.
          </p>
          <p>
            Wir zeigen nun, dass $\halt$ unentscheidbar ist, dass es also keine Möglichkeit gibt,
            das Nichtterminieren einer Maschine $M$ auf Eingabe $x$ vorauszusehen und abzufangen.
          </p>
          <div
            class="well container theorem"
          >
            <span
              class="numbered-title"
            >Theorem 
              <NumberedTitle>7.6.1</NumberedTitle>
               
            </span><b>(Unentscheidbarkeit des Halteproblems).</b>
            Die Sprache \(\halt\) ist unentscheidbar.
          </div>
          <p>
            Ich gebe erst einmal einen kurzen und knappen Widerspruchsbeweis. Falls das ihnen zu schnell
            ging,
            lesen Sie den zweiten Beweis, in dem ich mir mehr Zeit nehme.
          </p>
          <div
            class="well container"
          >
            <p>
              <b>Kurzer Beweis per Wiederspruch.</b>
               Nehmen wir an, es gäbe eine Maschine $H$,
              die $\halt$ entscheidet. Dann wäre auch die Sprache
            </p>
            $$\begin{align*}
            \diag := \{\enc(M) \ | \ \textnormal{$M$ akzeptiert $\enc(M)$} \}
            \end{align*}$$
            <p>
              entscheidbar. Warum? Wir können einfach schauen, ob das Eingabewort $c$ die Form $\enc(M)$
              hat
              und in diesem Fall das Wort $\enc(M) \enc(M)$ der Maschine $H$ übergeben.
              Die Sprache $\diag$ ist, salopp ausgedrückt, die Menge aller Turingmaschinen, die ihre
              eigene
              Codierung als Inputwort akzeptieren. Ebenso wäre auch
            </p>
            $$\begin{align*}
            \negdiag := \{\enc(M) \ | \ \textnormal{$M$ akzeptiert $\enc(M)$ nicht}\}
            \end{align*}$$
            <p>
              entscheidbar; wir müssen ja nur $\diag$ entscheiden und dann das Ergebnis negieren.
              $\negdiag$
              ist sozusagen die Menge aller Turingmaschinen, die 
              <i>nicht</i>
               ihre eigene Codierung als
              Inputwort akzeptieren. Da $\negdiag$ nach Annahme entscheidbar ist, gibt es eine Maschine
              $D$, die $\negdiag$ entscheidet.
            </p>
            <p>
              Wir fragen uns jetzt: gehört $\enc(D)$ selbst zu $\negdiag$?
            </p>
            $$\begin{align*}
            \enc(D) \in \negdiag&amp;\Longleftrightarrow \textnormal{$D$ akzeptiert $\enc(D)$ nicht}
            \tag{nach Definition von $\negdiag$} \\
            &amp;\Longleftrightarrow \textnormal{$\enc(D) \not \in L(D)$} \tag{Bedeutung der Notation $L(D)$}
            \\
            &amp;\Longleftrightarrow \enc(D) \not \in \negdiag \tag{nach Annahme $L(D) = \negdiag$}
            \end{align*}$$
            <p>
              Also $\enc(D) \in \negdiag \Longleftrightarrow \enc(M) \not \in \negdiag$, ein Widerspruch.
              Unsere
              Annahme, dass $\halt$ entscheidbar sei, ist also falsch.<span
                class="qed"
              >\(\square\)</span>
            </p>
          </div>
          <div
            class="well container"
          >
            <b>Ausführlicher Beweis.</b>
             Ich finde Beweise durch Widerspruch immer
            etwas unintuitiv, weil man die ganze Zeit im Konjunktiv argumentieren muss.
            Daher hier ein Beweis ohne Widerspruch. Wir zeigen, dass $\halt$ unentscheidbar ist,
            indem wir für eine beliebige Turingmaschine $M$ zeigen, dass sie $\halt$ nicht entscheidet,
            indem wir nämlich ein Eingabewort $z \in \Sigma^*$ konstruieren, auf dem $M$ scheitert, also
            entweder
            <ol>
              <li>
                \(f_H(z) = \texttt{accept}\) aber \(z \not \in \halt\), oder 
              </li>
              <li>
                \(f_H(z) = \texttt{reject}\) aber \(z \in \halt\) , oder 
              </li>
              <li>
                \(f_H(z) = \texttt{undefined}\), d.h. $H$ terminiert auf Eingabewort $z$ nicht.
              </li>
            </ol>
            Wir setzen nun $y := \enc(D)$ und $z := yy$, wobei \(D\) eine neue
            Turingmaschine ist, die wir auf Basis von \(H\)
            konstruieren werden.
            Also noch einmal. Für eine beliebige, uns gegebene
            Turingmaschine \(H\), werden wir eine neue Turingmaschine
            \(D\) bauen und sie codieren als \(y := \enc(D)\), so dass
            entweder
            <ol>
              <li>
                \(f_H(yy) = \texttt{accept}\) aber \(yy \not \in \halt\), oder
              </li>
              <li>
                \(f_H(yy) = \texttt{reject}\) aber \(yy \in \halt\), oder 
              </li>
              <li>
                \(f_H(yy) = \texttt{undefined}\).
              </li>
            </ol>
            Wenn uns dies gelingt, so haben wir gezeigt, dass \(H\) nicht
            die Sprache \(\halt\) entscheidet: im Fall 3 terminiert
            \(H\) ja nicht einmal; in Fall 1 und 2 liefert \(H\) zwar
            eine Antwort, aber die falsche.
            Der Code für \(D\) ist sehr einfach:
<pre
  class="listing"
>
<code>def D(x):</code>
 
<code>if H(xx) == accept then</code>
 
 
<code>reject</code>
 
 
<code>else</code>
 
 
<code>accept</code>
</pre>
            <p>
               Zur Erinnerung: $y := \enc(D)$. Wir unterscheiden drei Fälle.
            </p>
            <ul>
              <li>
                \(H(yy) = \texttt{reject}\). Dann geht der Aufruf von
                \(D(y)\) also in den 
                <tt>else</tt>-Teil
                in den Zeilen 4-5 und
                \(D(y) = \texttt{accept}\), somit
                $yy = \enc(D)y \in \halt$ Wir befinden uns
                in Fall 1: \(y y \in \halt\) aber \(H(yy)= \texttt{reject}\).
                Die Maschine \(H\) hat eine falsche Antwort
                für \(\halt\) geliefert.
              </li>
              <li>
                \(H(yy) = \texttt{accept}\). Dann geht
                der Aufruf von \(D(y)\) in Zeile 3,
                und \(D(y) = \texttt{reject}\), somit \(yy = \enc(D) y \not \in \halt\).
                Wir befinden uns in Fall 2: \(yy \not \in \halt\)
                und \(H(yy) = \texttt{accept}\). Die Maschine
                \(H\) hat abermals eine falsche Antwort geliefert.
              </li>
              <li>
                \(H(yy)\) terminiert nicht. Dann befinden
                wir uns in Fall 3: \(H\) kann
                \(\halt\) nicht entscheiden,
                denn Mindestbedingung hierfür wäre ja,
                auf jedem Eingabewort zu terminieren.
              </li>
            </ul>
            <p>
            </p>
            In jedem Fall sehen wir, dass \(H\) auf dem Eingabewort
            \(yy\) einen Fehler macht und somit \(\halt\) nicht
            entscheidet. Da das für 
            <i>jede</i>
             Turingmaschine
            geht, schließen wir: keine Turingmaschine kann
            die Sprache \(\halt\) entscheiden; sie ist unentscheidbar.<span
              class="qed"
            >\(\square\)</span>
          </div>
          <p>
            Ein Student hat am 26. Juni 2024 angemerkt, dass die Sprache
          </p>
          $$\begin{align*}
          \negdiag = \{\enc(M) \ | \ \textnormal{$M$ akzeptiert $\enc(M)$ nicht}\}
          \end{align*}$$
          <p>
            ja eine extrem konstruierte, nicht wirklich relevante Sprache sei (da hatte er Recht). Insofern
            sei es auch nicht relevant, dass $\negdiag$ unentscheidbar ist. Das ist allerdings auch nicht,
            was uns interessiert: unser Ziel war, zu zeigen, dass $\halt$ unentscheidbar ist, und
            die Unentscheidbarkeit von $\negdiag$ war ein Schritt auf diesem Weg. Dass $\halt$
            unentscheidbar ist,
            ist in der Tat relevant, denn daraus folgt (nicht direkt, aber mit ein paar technischen Tricks),
            dass im Prinzip
            <i>jede</i>
             nichttriviale Frage über das Verhalten eines Programmcodes unentscheidbar ist.
            Also sind
            auch Fragen wie "Kann das Programm abstürzen?" oder "Kann ein unautorisierter Nutzer Zugang zu
            XYZ erhalten?" unentscheidbar.
          </p>
          <div
            class="alert-info"
          >
            Das Wort 
            <i>Unentscheidbarkeit</i>
             verwenden wir hier in seiner
            technischen Bedeutung,
            die wir definiert haben: es gibt keine Turingmaschine, die das Problem entscheidet, also
            auf jeder Eingabeinstanz terminiert und die richtige Antwort liefert. Es gibt also in der Tat
            Raum für Algorithmen, die Software untersuchen und diese gegebenenfalls verifizieren oder Fehler
            / Sicherheitslücken finden. Dies ist im Prinzip das sehr real existierende Forschungsfeld der
            Programmverifikation. Die Unentscheidbarkeit des Halteproblems impliziert nicht, dass man
            auf dem Feld der Programmverifikation keine Fortschritte erzielen kann; sie impliziert nur,
            dass es keinen ultimaten Programmverifikator bzw. Bugfinder gibt.
          </div>
        </div>
      </div>
    </div>
  </div>
</section>
</body>
