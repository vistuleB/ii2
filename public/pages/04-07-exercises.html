<div id="rightSideWrapper">

        <div class="content">
            <div class='chapter'>
                <div class='subChapter'>
                    <h1 class='hidden-title'>
                        <span class='subChapterTitle'>4.7 Übungsaufgaben</span>
                    </h1>


                    <h3>Reguläre Sprachen und primitive Rekursion</h3>
                    <div class='well well-lg numbered-exercise container'>
                        <p><span class='numbered-title'>Übungsaufgabe</span>
                            Sei $\Sigma = \{\sigma_1, \sigma_2, \dots, \sigma_k\}$ ein endliches Alphabet. Wir
                            können jedes Zeichen $\sigma_i \in \Sigma$ als
                            natürliche Zahl $i$ codieren. Ein Wort $\alpha \in \Sigma^*$
                            wird somit zu einer Folge $(a_1, a_2, \dots, a_n) \in \N^*$, was
                            wir wiederum mit den Methoden aus
                            <a href="02-02-examples-of-equipotent-sets.html">Kapitel 2.2</a>
                            als <em>eine</em> natürliche Zahl $\bar{\alpha}$ codieren können.
                            Mittels dieser Codierung wird eine Sprache $L \subseteq \Sigma^*$
                            zu einer Funktion
                        </p>
                        \begin{align*}
                        f_L : \N & \rightarrow \{0,1\} \\
                        a & \mapsto
                        \begin{cases}
                        1 & \textnormal{ if $\exists \alpha \in L$ with $\bar{\alpha} = a$} \\
                        0 & \textnormal{ else.}
                        \end{cases}
                        \end{align*}
                        <p>
                            Sei $L$ eine reguläre Sprache. Zeigen Sie, dass $f_L$ primitiv rekursiv ist!
                        </p>
                    </div class='numbered-exercise'>


                    <h3>Reguläre Sprachen und Schaltkreise</h3>

                    <p>
                        Wir können jedes Zeichen $\sigma \in \Sigma$ als
                        Bitstring $x_{\sigma} \in \cube^k$ codieren, mit $k = \ceil{\log_2|\Sigma|}$, und
                        damit jedes $\alpha = (a_1, \dots, a_n) \in \Sigma^*$ als $x_a \in \cube^*$ mit $nk$ Bits.
                        Smit wird jede Sprache $L \subseteq \Sigma^*$ zu einer Funktion
                        $f_L : \cube^* \rightarrow \cube$ mittels</p>
                    \begin{align*}
                    f_L : \cube^* & \rightarrow \cube \\
                    y & \mapsto
                    \begin{cases}
                    1 & \textnormal{if $\exists \alpha \in L: x_\alpha = y$} \\
                    0 & \textnormal{else.}
                    \end{cases}
                    \end{align*}
                    <p>
                        Für festes $n$ definieren wir $f_L^n : \cube^n \rightarrow \cube$ als die
                        Restriktion von $f_L$ auf $\cube$, also die Funktion, die nur $n$-Bit-Strings
                        als Input akzeptiert.
                    </p>
                    <p>
                        Zeigen Sie: wenn $L \subseteq \Sigma^*$ regulär ist, dann gibt es für
                        jedes $n$ einen Schaltkreis $C$ mit $O(n)$ Gates, der $f_L$ berechnet.
                    </p>
                </div class="subchapter">

                <div class='well well-lg numbered-exercise container'>
                    <p><span class='numbered-title'>Übungsaufgabe</span>
                        Verbessern Sie die obige Konstruktion: Ihr Schaltkreis $C$ sollte nun
                        Tiefe $O(\log(n))$ haben und vorzugsweise immer noch $O(n)$ Gates.
                    </p>
                </div class='numbered-exercise'>


                <div class='well well-lg numbered-exercise container'>
                    <p><span class='numbered-title'>Übungsaufgabe</span><strong> (Challenge).</strong>
                        Betrachten wir eine Variante des endlichen Automaten, bei der
                        der Automat <em>zurückspulen</em> kann. Der Automat hat also
                        einen "Lesekopf", mit dem er auf einem Zeichen des Eingabewortes steht
                        (anfangs auf dem ersten). In jedem Schritt kann er nach rechts oder links
                        wechseln. Es gibt zwei spezielle Zeichen, die markieren, wo das
                        Wort aufhört: $\lt$ und $\gt$. Die Zustandsübergangsfunktion ist also
                    </p>
                    \begin{align*}
                    \delta: Q \times (\Sigma \cup \{\lt, \gt\}) \rightarrow Q \times \{L, R\} \ .
                    \end{align*}
                    <p>
                        Wenn z.B. $\delta(q, x) = (r, L)$ ist, dann heißt das: <em>wenn Du im
                            Zustand $q$ bist und der Lesekopf ein $x$ liest, dann wechsle in den
                            Zustand $r$ und gehe nach links.
                        </em>
                    </p>
                    <p>
                        Der Automat hat genau einen akzeptierenden und einen ablehnenden Zustand.
                        Wenn ein solcher Zustand erreicht wird, hält der Automat an und gibt
                        1 bzw. 0 aus.
                        Die von so einem Automaten $M$ akzeptierte Sprache $L(M)$ ist dann definiert als
                        die Menge aller Wörter $\alpha$, die $M$ in einen akzeptierenden
                        Zustand bringen. Beachten Sie, dass $M$ möglicherweise in eine Endlosschleife
                        geraten kann. In diesem Falle ist $\alpha$ <em>kein</em> Wort in $L(M)$.
                    </p>
                    <p>
                        Zeigen Sie, dass $L(M)$ eine reguläre Sprache ist. Dass man also aus $M$
                        einen neuen Automaten $M'$ bauen kann, der nur nach rechts laufen kann.
                    </p>
                </div class='numbered-exercise'>


                <div class='well well-lg numbered-exercise container'>
                    <p><span class='numbered-title'>Übungsaufgabe</span>
                        Sei $\Sigma = \{1,2, \dots, k\}$ und $L$ die Sprache aller
                        Wörter, in denen mindestens ein Zeichen fehlt, also
                    </p>
                    \begin{align*}
                    L = \bigcup_{i=1}^k (\Sigma \setminus \{i\})^*
                    \end{align*}
                    <p>
                        Zeigen Sie, dass ein endlicher Automat für $L$ mindestens $2^k$ Zustände braucht.
                    </p>
                </div class='numbered-exercise'>

                <div class='well well-lg numbered-exercise container'>
                    <p><span class='numbered-title'>Übungsaufgabe</span>
                        Schreiben Sie eine reguläre Grammatik für $L$ mit höchstens $k+1$ Nichtterminalen.
                    </p>
                </div class='numbered-exercise'>


                <div class='well well-lg numbered-exercise container'>
                    <p><span class='numbered-title'>Übungsaufgabe</span> <strong>(Challange.)</strong>
                        Sei $L$ die Sprache aus der vorherigen Aufgabe und
                        $\bar{L} = \Sigma^* \setminus L$ ihr Komplement. $\bar{L}$ ist also
                        die Sprache aller Wörter, in denen jedes Zeichen aus $\Sigma$ mindestens
                        einmal vorkommt.
                    </p>
                    <p>
                        Zeigen Sie, dass jede reguläre Grammatik für $\bar{L}$ mindestens $2^k$
                        Nichtterminale benötigt.
                    </p>
                </div class='numbered-exercise'>



            </div class='chapter'>


        </div class="content">
    </div class="rightSideWrapper">