<div id="rightSideWrapper">


        <div class="content">



            <div class='chapter'>

                <div class='subChapter'>
                    <h1 class='hidden-title'>
                        <span class='subChapterTitle'>4.1 Turingmaschinen: Formale Definition und Beispiele</span>
                    </h1>
                    <p>
                        Eine Turingmaschine besteht aus einem <em>Band</em>, das in Zellen unterteilt ist und
                        in beide Richtungen unbegrenzt ist,
                        und einem <em>Schreib-Lese-Kopf</em>.
                        Dieser befindet sich in jedem Schritt auf einer
                        Zelle. Wie auch der endliche Automat oder der
                        Kellerautomat hat die Turingmaschine einen internen <em>Zustand</em>.
                        In jedem Schritt liest die Maschine das Zeichen, das sich in der aktuellen
                        Zelle des Bandes befindet (dort, wo der Kopf steht). Abhängig vom gelesenen Zeichen
                        \(s\) und dem internen Zustand \(q\) schreibt die Turingmaschine ein neues Symbol
                        \(s'\) in die Zelle, wechselt in einen neuen Zustand \(q'\) und bewegt
                        den Kopf um maximal eine Zelle, also nach link, rechts, oder gar nicht.
                    </p>
                    <figure class='centered-figure well container'>
                        <a class='left carousel-control-prev-icon' href='#turing-machine-example-01' data-slide='prev'>
                            <div class='carousel-nav-icon'>
                                <img src='../img/carousel-prev-icon.svg'>
                            </div>
                        </a>
                        <a class='right carousel-control-next-icon' href='#turing-machine-example-01' data-slide='next'>
                            <div class='carousel-nav-icon'>
                                <img src='../img/carousel-next-icon.svg'>
                            </div>
                        </a>
                        <div id='turing-machine-example-01' class='carousel' data-interval='false'
                            style='display:inline-block'>
                            <ol class='carousel-indicators'>
                                <li data-target='#turing-machine-example-01' data-slide-to='1' class='active'></li>
                                <li data-target='#turing-machine-example-01' data-slide-to='2'></li>
                                <li data-target='#turing-machine-example-01' data-slide-to='3'></li>
                                <li data-target='#turing-machine-example-01' data-slide-to='4'></li>
                                <li data-target='#turing-machine-example-01' data-slide-to='5'></li>
                                <li data-target='#turing-machine-example-01' data-slide-to='6'></li>
                                <li data-target='#turing-machine-example-01' data-slide-to='7'></li>
                                <li data-target='#turing-machine-example-01' data-slide-to='8'></li>
                            </ol>
                            <div class='carousel-inner' style='display:inline-block'>
                                <div class='item active'><img src='../img/turing-machines/exampe-1/01.svg'
                                        style='height:15em'></div>
                                <div class='item'><img src='../img/turing-machines/exampe-1/02.svg' style='height:15em'>
                                </div>
                                <div class='item'><img src='../img/turing-machines/exampe-1/03.svg' style='height:15em'>
                                </div>
                                <div class='item'><img src='../img/turing-machines/exampe-1/04.svg' style='height:15em'>
                                </div>
                                <div class='item'><img src='../img/turing-machines/exampe-1/05.svg' style='height:15em'>
                                </div>
                                <div class='item'><img src='../img/turing-machines/exampe-1/06.svg' style='height:15em'>
                                </div>
                                <div class='item'><img src='../img/turing-machines/exampe-1/07.svg' style='height:15em'>
                                </div>
                                <div class='item'><img src='../img/turing-machines/exampe-1/08.svg' style='height:15em'>
                                </div>
                            </div class='carousel-inner'>
                        </div class='carousel'>
                    </figure>

                    <p>
                        Sie können sich das Band auch als Magnetband vorstellen, das nach vorn oder nach hinten gespult
                        wird, anstatt dass der Kopf sich bewegt. Am Anfang steht auf dem Band das
                        <em>Eingabewort</em> und der Kopf auf dem ersten Symbol dieses Wortes. Die Turingmaschine
                        wendet
                        nun ihre Regeln an, bis Sie einen
                        <em>Endzustand</em> erreicht. Bei <em>Entscheidungsproblemen</em>, wo uns nur
                        eine Ja/Nein-Antwort interessiert, wird die Antwort durch den Entzustand angegeben:
                        der Zustand $\qaccept$ entspricht einem <em>Ja</em>, der Zustand
                        $\qreject$ entspricht einem <em>Nein</em>. Diese zwei Endzustände reichen im Allgemeinen
                        aus. Wenn wir von der Maschine eine komplexere Ausgabe als Ja/Nein erwarten, so
                        betrachten wir als <em>Ausgabe der Turingmaschine</em> den Inhalt des Bandes zu dem
                        Zeitpunkt, da die Maschine den Zustand $\qaccept$ erreicht.
                        Was brauchen wir also, um so eine Turingmaschine
                        und ihre Arbeitsweise zu beschreiben?
                    </p>
                    <div class='well container theorem'>
                        <p><span class='numbered-title'>Definition</span><strong>(Turingmaschine).</strong> Eine
                            Turingmaschine besteht aus folgenden Elementen:</p>
                        <ol>
                            <li>Einem endlichen Eingabe-Alphabet \(\Sigma\). Dies sind die Symbole, die für das
                                Eingabewort in
                                Frage kommen.
                            </li>
                            <li>
                                Einem endlichen Bandalphabet \(\Gamma\); das sind die Symbole, die auf dem Band
                                stehen dürfen. Offensichtlich muss \(\Sigma \subseteq \Gamma\) gelten. Jede
                                Zelle kann genau ein Zeichen aus \(\Gamma\) enthalten. Darüberhinaus
                                gibt es noch das sogenannte Blanksymbol \(\square \in \Gamma \setminus \Sigma\). Dies
                                zeigt an, dass die Zelle im Moment leer ist. Im obigen Beispiel ist
                                die Zelle links vom ersten \(a\) beispielsweise leer.
                                Am Anfang steht auf dem Band also ein Eingabewort \(w \in \Sigma^*\) und
                                rechts und links davon unendlich viele \(\square\)-Symbole.
                            </li>
                            <li>
                                Einer endliche Menge \(Q\) an inneren Zuständen. Dies entspricht in etwa
                                den Prozessor-Registern eines Computers. Ein Zustand \(\texttt{start} \in Q\)
                                ist der Startzustand, in welchem sich die Maschine zu Beginn befindet.
                            </li>
                            <li>Einer Zustandsübergangsfunktion \(\delta\), die sagt, was die Turingmaschine tun soll,
                                wenn Sie im Zustand \(q\) ist und Zeichen \(s\) liest. Formal:
                                \begin{align*}
                                \delta : Q \times \Gamma \rightarrow Q \times \Gamma \times \lsr \ ,
                                \end{align*}
                                wobei <tt>L</tt> für <em>gehe eine Zelle nach links</em> steht,
                                <tt>R</tt> für rechts und <tt>S</tt> für <em>stay</em>, also die Anweisung, den Kopf
                                nicht zu bewegen.
                            </li>
                            <li>
                                Zwei besonderen Zuständen $\qaccept$ und $\qreject$.
                            </li>
                        </ol>
                    </div class='well container theorem'>

                    <p>
                        Für die Turingmaschine in dem obigen Beispiel haben wir zwei Regeln gesehen:
                        \begin{align*}
                        \delta(q_2, b) & = (q_3, a, \texttt{R}) \\
                        \delta(q_3, \#) & = (q_4, b, \texttt{L})
                        \end{align*}
                    </p>

                    <h3>Was macht eine Turingmaschine?</h3>

                    Sie haben nun wohl bereits eine vage Vorstellung, was eine Turingmaschine macht.
                    Versuchen wir, es noch weiter zu formalisieren. Um den <em>Gesamtzustand</em> der
                    Turingmaschine zu beschreiben, also eine vollständige Momentaufnahme, reicht
                    nicht der aktuelle innere Zustand \(q\); wir brauchen auch den Bandinhalt und insbesondere
                    die Position, an der sich der Kopf befindet. Das alles zusammen nennt
                    man die <em>Konfiguration der Turingmaschine</em>. Wir wollen sie mit
                    uns bereits bekannten mathematischen Begriffen beschreiben.
                    <figure>
                        <img loading='lazy' src='../img/turing-machines/configuration.svg' style='height:20em'>
                    </figure>
                    <div class='well container theorem'>
                        <span class='numbered-title'>Definition</span>
                        Die <em>Konfiguration</em> einer Turingmaschine ist ein Element in
                        \(\Gamma^* \times Q \times \Gamma^*\), also
                        \begin{align*}
                        C = u q v
                        \end{align*}
                        wobei \(uv \in \Gamma^*\) der Bandinhalt ist, der
                        Schreib-Lese-Kopf auf dem ersten Zeichen von \(v\) steht und \(q\) der
                        innere Zustand der Turingmaschine ist. Das \(q\) in \(C\)
                        kennzeichnet also sowohl die Position des Schreib-Lese-Kopfes auf dem Band
                        sowie den inneren Zustand
                        Die Menge aller Konfigurationen ist
                        \begin{align*}
                        \mathcal{C} := \Gamma^* \times Q \times \Gamma^*
                        \end{align*}
                        Der <em>Zustand einer Konfiguration</em> \(C = uqv\) ist \(q\), also der innere
                        Zustand, in dem sich die Maschine gerade befindet.
                        Wir bezeichnen mit $\state(C)$. Formal:
                        \begin{align*}
                        \state: \mathcal{C} & \rightarrow Q \\
                        uqv & \mapsto q \ .
                        \end{align*}
                        Eine Konfiguration \(C\) ist
                        eine <em>akzeptierende Endkonfiguration</em> wenn $\state(C) = \qaccept$ ist;
                        eine <em>ablehnende Endkonfiguration</em> , wenn $\state(C) = \qreject$ ist.
                        In beiden Fällen ist \(C\) eine <em>Endkonfiguration</em>.
                    </div class='well container theorem'>
                    <p>
                        Wenn also das Eingabewort \(w \in \Sigma^*\) und $\qstart$ der Startzustand ist, dann ist
                        \begin{align*}
                        C_{\rm start} = \qstart{} w
                        \end{align*}
                        die <em>Startkonfiguration</em>.
                    </p>
                    <div class="alert-info">
                        <strong>Die Rolle des \(\square\)-Symbols</strong>. Das Band der Turingmaschine ist ja
                        unendlich.
                        Um eine Momentaufnahme dennoch als endliches Objekt beschreiben zu können,
                        lassen wir die \(\square\)-Symbole links und rechts vom "eigentlichen" Bandinhalt weg.
                        Bei einer Konfiguration \(uqv\) stehen also links vom \(u\) und rechts vom \(v\) unendlich
                        viele \(\square\)-Symbole auf dem Band. Nach der formalen Definition
                        \(uqv \in \Gamma^* \times Q \times \Gamma^*\) ist es nicht verboten, dass \(u\) auch mit
                        einem \(\square\)-Symbol beginnt oder \(v\) mit einem aufhört. Allerdings wären die
                        Konfiguration
                        \(\square u q v\) und \(u q v \square\) genauso gut mit
                        \(u q v\) beschrieben. Wir können uns also auf die Konvention einigen, dass
                        \(\square\) nie am Rande einer Konfiguration \(uqv\) steht.
                        Beachten Sie auch, dass die Zellen nicht "numeriert" sind. Die beiden folgenden
                        Momentaufnahmen
                        <figure>
                            <img loading='lazy' src='../img/turing-machines/configuration-two.svg' style='height:18em'>
                        </figure>
                        können also beide mit der Konfiguration \(aAAaq\#ba\) beschrieben werden, obwohl
                        die Zellen nun andere Inhalte haben, weil die Turingmaschine es irgendwie geschafft
                        hat, den ganzen Bandinhalt um eins nach rechts zu kopieren. Es sollte klar
                        sein, dass die Turingmaschine keine Möglichkeit hat, die obere von der unteren
                        Situation zu unterscheiden, und dass es somit nur recht und billig ist, beide
                        als eine identische Konfiguration aufzufassen.
                        <p>
                            All diese Schwierigkeiten verschwinden, wenn wir uns den Speicher einer Turingmaschine
                            nicht
                            als unendliches Band vorstellen, sondern als zwei Stapel, einer links vom Kopf und einer
                            rechts vom Kopf. Allerdings hat sich die Vorstellung vom Band irgendwie als
                            Standard durchgesetzt. Hier sehen Sie die gleiche Konfiguration in dem Modell
                            mit zwei Stapeln:
                        </p>
                        <figure>
                            <img loading='lazy' src='../img/turing-machines/two-stacks.svg' style='height:18em'>
                        </figure>
                        <p>
                            Alternativ können wir auch der Turingmaschine verbieten, das Blank-Symbol $\Box$ jemals
                            zu schreiben. Dann wäre also
                            $\delta: Q \times \Gamma \rightarrow Q \times (\Gamma \setminus \{\Box\}) \times \lsr$.
                            All diese Betrachtungsweisen unterscheiden sich nicht wesentlich. Wir bleiben
                            bei unserem "alten" $\delta$, erlauben also, $\Box$ zu schreiben, und
                            leben damit, dass $uqv$ und $\Box \Box u q v \Box$ formal zwei verschiedene Konfigurationen
                            sind, auch wenn beide irgendwie das selbe beschreiben.
                        </p>

                    </div>

                    <p>
                        Formal definiert \(\delta\) nun auch
                        eine Funktion auf der Menge der Konfigurationen:
                    </p>
                    <div class='well container theorem'>
                        <span class='numbered-title'>Definition</span>
                        <strong>(erweiterte Zustandsübergangsfunktion)</strong>
                        Die erweiterte Zustandsübergangsfunktion einer Turingmaschine ist
                        \begin{align*}
                        \hat{\delta} : \mathcal{C} \rightarrow \mathcal{C} \
                        \end{align*}
                        Sie beschreibt für eine Konfiguration \(C\), welches die Konfiguration
                        im nächsten Schritt ist.
                        Per Konvention
                        legen wir fest, dass
                        \(\hat{\delta}(C) = C\) gilt, wenn \(C\) eine Endkonfiguration ist.

                    </div class='well container theorem'>

                    Unsere obige Turingmaschine hat beispielsweise die Regeln
                    \(\delta(q_2,b) = (q_3, a,R)\) und
                    \(\delta(q_3, \#) = (q_4, b, \texttt{L})\), und somit würden
                    \begin{align*}
                    \hat{\delta}(aaAq_2b\#ba) & = aaAaq_3\#ba \\
                    \hat{\delta}(aaAaq_3\#ba) & = aaAq_4abba \\
                    \hat{\delta}(abAq_2bba\#) & = abAaq_3ba\# \\
                    \end{align*}
                    gelten. Sie sehen:
                    Die Definition von $\hat{\delta}$ ist nichts wirklich Tiefgründiges, sondern einfach
                    eine Implementierung der Turingmaschinen-Momentaufnahme mit uns bereits
                    geläufigen mathematischen "Datenstrukturen" (hier: der Menge $\Gamma^* \times Q \times \Gamma^*$).
                    Stellen Sie sich einfach
                    vor, Sie müssten eine Turingmaschine in Java implementieren. Dann würden Sie es wahrscheilich
                    irgendwie so ähnlich machen.


                    <h3>Ausgabekonfiguration einer Turingmaschine</h3>

                    Die Funktion \(\hat{\delta}\) bildet aus einer Konfiguration die
                    Folgekonfiguration. Wir definieren nun
                    \begin{align*}
                    \hat{\delta}^{(i)} (C) := \underbrace{\hat{\delta}(\hat{\delta}(\dots (\hat{\delta}}_{i \textnormal{
                    mal}} (C) \dots)))
                    \end{align*}
                    also die Konfiguration, die die Turingmaschine nach \(i\) Rechenschritten erreicht hat.
                    Weiterhin definieren wir
                    \(\hat{\delta}^* (C)\) als die Endkonfiguration, die bei wiederholter
                    Anwendung von $\hat{\delta}$ schlussendlich erreicht wird.
                    Hier taucht ein Problem auf: es ist nicht gesagt, dass die Turingmaschine,
                    von Konfiguration \(C\) beginnend, überhaupt irgendwann in einer Endkonfiguration landen
                    wird. Daher kann \(\hat{\delta}^*\) auch <tt>undefined</tt> sein:
                    \begin{align*}
                    \hat{\delta}^* (C) := \begin{cases}
                    \hat{\delta}^{(i)} (C) &
                    \textnormal{ wenn es ein \(i\) gibt, so dass $\hat{\delta}^{(i)} (C)$ eine Endkonfiguration ist} \\
                    \texttt{undefined} & \textnormal{sonst.}
                    \end{cases}
                    \end{align*}
                    <p>
                        Nochmal zur Verdeutlichung: wenn $\delta^{(i)}(C)$ eine Endkonfiguration ist,
                        dann ist auch $\delta^{(j)}(C)$ eine, für jedes $j \geq i$, weil
                        wir $\hat{\delta}(C') = C'$ für jede Endkonfiguration $C'$ definiert haben.
                        Es spielt also in der obigen Formulierung
                        <em>wenn es ein $i$ gibt</em> keine Rolle, welches solche $i$ wir wählen.
                    </p>
                    Für ein Eingabewort \(x \in \Sigma^*\) können wir nun das Ergebnis der Berechnung
                    von Turingmaschine \(M\) auf \(x = x_1 \dots x_n\) definieren:
                    \begin{align*}
                    \hat{M}(x) := \hat{\delta}^* (\qstart{} x_1 x_2 x_3 \dots x_n) \ .
                    \end{align*}
                    Wir beginnen also mit der Startkonfiguration und lassen die Turingmaschine dann
                    laufen, bis sie einen Endzustand erreicht. Die erreichte Konfiguration bezeichnen
                    wir mit \(\hat{M}(x)\). Falls nie ein Endzustand erreicht wird (die Turingmaschine also
                    endlos läuft),
                    ist \(\hat{M}(x)\) <tt>undefined</tt>.


                    <h2>Sprachen entscheiden</h2>
                    <p>
                        Ein <em>Entscheidungsproblem</em> ist eine Funktion \(P : \Sigma^* \rightarrow
                        \{\texttt{true}, \texttt{false}\}\), beispielsweise: <em>gegeben ein Wort,
                            stellt dieses Wort ein korrektes Java-Programm dar?</em>
                        oder <em>gegeben eine Zahl in Dezimalschreibweise, ist dies
                            eine Primzahl?</em> Eine äquivalente Sichtweise ist die
                        eines Entscheidungsproblems als <em>Sprache</em> \(L \subseteq \Sigma^*\).
                        Wir identifizieren \(L\) hier mit der Menge aller Wörter \(x\) mit
                        \(P(x) = \texttt{true}\). Wenn wir es mit einem Entscheidungsproblem
                        zu tun haben und dieses mit einer Turingmaschine lösen wollen,
                        so interessiert uns am Endergebnis \(\hat{M}(x)\) (also der erreichten Endkonfiguration)
                        nicht der Bandinhalt, sondern nur, ob der Zustand <tt>accept</tt> oder
                        <tt>reject</tt> ist. Wir definieren daher
                        \begin{align*}
                        f_M(x) = \begin{cases}
                        \texttt{accept} & \textnormal{ falls $\state(\hat{M}(x)) = \qaccept$, wenn also $\hat{M}(x)$
                        eine akzeptierende Endkonfiguration ist, }\\
                        \texttt{reject} & \textnormal{ falls $\state(\hat{M}(x)) = \qreject$ ,}\\
                        \texttt{undefined} & \textnormal{ falls $\hat{M}(x) = \texttt{undefined}$ }
                        \end{cases}
                        \end{align*}
                    </p>
                    <div class='well container theorem'>
                        <span class='numbered-title'>Definition</span>
                        <strong>(Turingmaschine entscheidet eine Sprache)</strong>
                        Eine Turingmaschine \(M\)
                        <em>entscheidet</em> die Sprache \(L \subseteq \Sigma^*\) wenn
                        <ol>
                            <li>
                                \(f_M(x) = \texttt{accept}\) für alle \(x \in L\),
                            </li>
                            <li>
                                \(f_M(x) = \texttt{reject}\) für alle \(x \in \Sigma^* \setminus L\).
                            </li>
                        </ol>
                        Insbesondere heißt das, dass \(M\) auf jedem Eingabewort terminiert.
                        <p>
                            Eine Sprache \(L\) heißt <em>entscheidbar</em>, wenn
                            es eine Turingmaschine gibt, die sie entscheidet.
                        </p>
                    </div class='well container theorem'>

                    <div class='well container theorem'>
                        <span class='numbered-title'>Definition</span>
                        <strong>(Turingmaschine akzeptiert eine Sprache)</strong>
                        Eine Turingmaschine \(M\) <em>akzeptiert</em> die Sprache
                        \(L \subseteq \Sigma^*\) wenn
                        \begin{align*}
                        x \in L \Longleftrightarrow f_M(x) = \texttt{accept}
                        \end{align*}
                        für alle \(x \in \Sigma^*\) gilt. Das heißt, dass \(M\) für \(x \not \in \Sigma^*\)
                        entweder irgendwann den Endzustand $\qreject$ erreicht oder
                        nie einen Endzustand erreicht.
                        <p>
                            Eine Sprache \(L \subseteq \Sigma^*\) heißt <em>semi-entscheidbar</em>,
                            wenn es eine Turingmaschine \(M\) gibt, die \(L\) akzeptiert.
                        </p>
                    </div class='well container theorem'>

                    <p>In beiden Definition verlangen wir natürlich, dass
                        \(\Sigma\) das Eingabealphabet der Turingmaschine ist.
                    </p>
                    <h2>Funktionen berechnen</h2>

                    <p>
                        Oft wollen wir nicht nur eine Sprache \(L \subseteq \Sigma^*\)
                        entscheiden, sondern eine Funktion \(g: \Sigma_1^* \rightarrow \Sigma_2^*\)
                        berechnen. Mit einer Turingmaschine heißt das einfach, dass
                        bei Eingabe \(x \in \Sigma_1^*\) die Turingmaschine in einer
                        akzeptierenden Endkonfiguration \(C\) landet, und in \(C\) steht
                        dann \(g(x)\) auf dem Band. Formal müssen wir noch klären, was <em>\(g(x)\) steht
                            auf dem Band</em> bedeutet.
                    </p>
                    <div class='well container theorem'>
                        <span class='numbered-title'>Definition</span>
                        <strong>(Turingmaschine berechnet eine Funktion)</strong>
                        Seien \(\Sigma_1, \Sigma_2\) zwei endliche Alphabete und
                        \begin{align*}
                        g : \Sigma_1^* \rightarrow \Sigma_2^*
                        \end{align*}
                        eine Funktion. Eine Turingmaschine \(M\) <em>berechnet die Funktion \(g\)</em>, wenn
                        <ol>
                            <li>
                                \(\Sigma_1\) das Eingabealphabet von \(M\) ist,
                            </li>
                            <li>
                                \(\Sigma_1 \cup \Sigma_2 \subseteq \Gamma\) gilt und
                                \(\square \in \Gamma \setminus (\Sigma_1 \cup \Sigma_2)\); das Blank-Symbol
                                ist also weder Teil das Eingabealphabets noch des Ausgabealphabets.
                            </li>
                            <li>
                                $M$ terminiert für jedes $x \in \Sigma^*$.
                            </li>
                            <li> In der Endkonfiguration $\hat{M}(x)$ steht auf dem Arbeitsband das
                                Wort \(g(x) \in \Sigma_2^*\) und der Kopf steht ganz links, also
                                $\hat{M}(x) = \qaccept{} g(x)$.
                            </li>
                        </ol>
                    </div class='well container theorem'>

                    <h2>Turingmaschinen und formale Grammatiken</h2>

                    <p>
                        Da Turingmaschinen sowohl in dem Kurs
                        <a href="../../BerKrea/index.html">Berechenbarkeit und Kreativität</a>
                        als auch
                        <a href="../../TI-2/index.html">Theoretische Informatik</a>
                        vorkommen, teilen sich die beiden Kurse diese Seiten.
                        Für Berechenbarkeit und Kreativität ist der Rest dieses Teilkapitels
                        allerdings weniger relevant, da formale Grammatiken nicht Teil des Kurses waren.
                    </p>

                    <div class='well container theorem'>
                        <span class='numbered-title'>Theorem</span>
                        Sei \(M\) eine Turingmaschine und \(L(M)\) die von ihr akzeptierte Sprache.
                        Dann gibt es eine formale Grammatik \(G\) mit \(L(G) = L(M)\). In anderen Worten:
                        formale Grammatiken sind mindestens so mächtig wie Turingmaschinen.
                    </div class='well container theorem'>
                    <div class='well container'>
                        <strong>Beweis.</strong>
                        Die Idee ist, dass wir eine Grammatik \(G\) schreiben, die
                        "in umgekehrter Reihenfolge" läuft, also
                        \begin{align*}
                        \texttt{\$} q_{\rm start} w \texttt{.} \Step{}^* S
                        \end{align*}
                        ableiten kann genau dann, wenn \(w \in S\) gilt. Wir brauchen
                        \(\texttt{\$}\) und \(\texttt{.}\) als Randmarkierungen. Wir lassen hier
                        temporär zu, dass die linke Seite ausschließlich aus Terminalsymbolen bestehen kann.
                        <p>
                            Hierfür definieren wir für jede Regel der Turingmaschine eine Grammatik-Regel:
                            \begin{align*}
                            \begin{array}{lcl}
                            \delta(q,x) = (r,y,\texttt{S} ) & \textnormal{wird zur Produktion} & qx \rightarrow ry \\
                            \delta(q,x) = (y,r,\texttt{R}) & \textnormal{wird zur Produktionen} & qx \rightarrow yr \\
                            \delta(q,x) = (y,r,\texttt{L}) & \textnormal{wird zu den Produktionen} & aqx \rightarrow ray
                            \textnormal{ für alle $a \in \Gamma$}
                            \end{array}
                            \end{align*}
                            Die Asymmetrie zwischen den Regeln, die den Kopf nach rechts verschieben und denen, die ihn
                            nach links verschieben, ergibt sich aus unserer Konvention, die Konfigurationen \(uqv\) so
                            zu
                            interpretieren, dass der Kopf auf dem ersten Symbol von \(v\)
                            und nicht etwa auf dem letzten von \(u\) steht.
                            Ein Problem ergibt sich, wenn \(q\) am Rand steht. Hierfür erlauben wir,
                            an den Rändern der Konfiguration \(\square\)-Symbole zu erzeugen:
                            \begin{align*}
                            \texttt{\$} & \rightarrow \texttt{\$} \square \\
                            \texttt{.} & \rightarrow \square \texttt{.} \
                            \end{align*}
                            Wenn der Kopf also vor dem \(\texttt{.}\) stehen sollte,
                            dann können wir
                            \begin{align*}
                            \texttt{\$}uq\texttt{.} \Step{} \texttt{\$}uq\square \texttt{.}
                            \end{align*}
                            anwenden und dann die Produktion, die der Regel von \(\delta(q,\square)\) entspricht.
                            Es sollte nun klar sein, dass folgendes gilt:
                        </p>
                        <div class='well subtheorem theorem'>
                            <span class='numbered-title'>Beobachtung</span>
                            Wenn \(\hat{\delta}^{(i)} (uqv) = u'q'v'\) gilt, die Turingmaschine also in
                            \(i\) Schritten von Konfiguration \(uqv\) nach \(u'q'v'\) übergeht, dann gilt in der gerade
                            entwickelten Grammatik auch
                            \begin{align*}
                            \texttt{\$}uqv\texttt{.} \Step{}^* \texttt{\$}\square^* u'q'v'\square^*\texttt{.}
                            \end{align*}
                        </div class='well container theorem'>
                        Als nächstes definieren wir <em>Aufräumregeln</em>: wenn \(q = \texttt{accept}\), dann
                        können wir jedes Zeichen löschen:
                        \begin{align*}
                        \texttt{accept}\ x & \rightarrow \texttt{accept} \\
                        x\ \texttt{accept} & \rightarrow \texttt{accept}
                        \end{align*}
                        wobei \(\texttt{accept}\) ein Nichtterminal der Grammatik ist.
                        Und somit gilt auch
                        \begin{align*}
                        \texttt{\$} u \ \texttt{accept} \ v \texttt{.} & \Step{}^*
                        \texttt{\$}\ \texttt{accept} \ \texttt{.}
                        \end{align*}
                        Als letzte Regel definieren wir:
                        \begin{align*}
                        \texttt{\$ }\ \texttt{accept}\ \texttt{.} \rightarrow S
                        \end{align*}
                        Wir haben nun eine Grammatik mit den folgenden Eigenschaften:
                        \begin{align*}
                        M(x_1 x_2 \dots x_n) = \texttt{accept} & \textnormal{ genau dann, wenn }
                        \texttt{\$} \texttt{start} x_1 x_2 \dots x_n \texttt{.} \Step{}^* S
                        \end{align*}
                        Wir bauen nun eine weitere Grammatik \(G\), in der wir jede Produktion \(\alpha \rightarrow
                        \beta\)
                        umdrehen, also durch \(\beta \rightarrow \alpha\) ersetzen. Zusätzlich definieren wir
                        Abschlussregeln
                        \begin{align*}
                        \texttt{\$} & \rightarrow \epsilon \\
                        \texttt{.} & \rightarrow \epsilon \\
                        \texttt{start} & \rightarrow \epsilon
                        \end{align*}
                        die die Randmarkierungen ersetzen. In dieser Grammatik gilt nun für
                        alle Wörter \(x \in \Sigma^*\):
                        \begin{align*}
                        x \in L(M) \Longleftrightarrow S \rightarrow
                        G: S \Step{}^* x
                        \end{align*}
                        und somit gilt \(L(G) = L(M)\). Zusammenfassend besitzt \(G\) also die Produktionen
                        \begin{align*}
                        S & \step{1} \texttt{\$} \ \texttt{accept} \ \texttt{.} \\
                        \texttt{accept} & \step{2} x \ \texttt{accept} \ | \ \texttt{accept} \ x \quad
                        \tag{ für jedes \(x \in \Gamma\)} \\
                        ry & \step{3} qx \quad \tag{ wenn $\delta(q,x) = (r,y, \texttt{S})$}\\
                        yr & \step{4} qx \quad \tag{ wenn $\delta(q,x) = (r,y, \texttt{R})$}\\
                        ray & \step{5} aqx \quad \tag{ wenn $\delta(q,x) = (r,y, \texttt{L})$, für jedes \(a \in
                        \Gamma\)} \\
                        \texttt{\$} \square & \step{6} \texttt{\$} \\
                        \texttt{.}\square & \step{7} \texttt{.} \\
                        \texttt{\$} & \step{8} \epsilon \\
                        \texttt{.} & \step{9} \epsilon \\
                        \texttt{start} & \step{10} \epsilon
                        \end{align*}
                        Um also ein Wort \(x \in L(M)\) abzuleiten, müssen wir
                        die akzeptierende Endkonfiguration \(C\) von \(M(x)\) "erraten" und dann
                        per Produktionen 1 und 2 die Wortform \(\texttt{\$}C\texttt{.}\) ableiten. Von da
                        an verwenden wir die Produktionen 3, 4, 5, 6, 7, um die Berechnung der Turingmaschine
                        \(M(x)\) von hinten nach vorne zu simulieren, bis wir bei
                        \(\texttt{\$} \texttt{start}\ x \texttt{.}\) angelangt sind. Dann
                        lassen wir \(\texttt{\$}, \texttt{start}, \texttt{.}\) mit den Produktionen 8, 9, 10
                        verschwinden und haben \(x\) abgeleitet.
                        <span class='qed'>\(\square\)</span>
                    </div class='proof'>
                </div subchapter>
            </div chapter>









        </div class="content">
    </div class="rightSideWrapper">