    <div id="rightSideWrapper">


        <div class="content">

            <div class='chapter'>



                <div class='subChapter'>
                    <h1 class='hidden-title'>
                        <span class='subChapterTitle'>1.6 Untere und obere Schranken</span>
                    </h1>

                    <p>
                        Wir haben zwei Methoden gesehen, zu einer beliebigen Booleschen Funktion
                        $f : \fcube$ einen Booleschen Schaltkreis zu konstruieren: top-down,
                        indem wir $f$ in $f_0$ und $f_1$ zerlegen und mit Hilfe eines
                        if-then-else-Gates wieder zusammenfügen; und bottom-up als DNF oder CNF.
                        Die so entstandenen Schaltkreise hatten Größe $O(2^n)$ (bzw. $O(n2^n)$ wenn wir
                        zuerst eine CNF oder DNF bauen und dann auf Fan-in 2 bestehen). Die offensichtliche
                        Frage: geht es besser? Die Antwort: Ja, aber nicht viel besser.
                    </p>

                    <div class='well container theorem'>
                        <p><span class='numbered-title'>Theorem</span> <strong>(Shannon).</strong> Es gibt
                            Boolesche Funktionen $f$, die keine Schaltkreise kleiner
                            als $\Omega(2^n / n)$ haben.
                        </p>
                    </div class='well container theorem'>

                    <div class='well container'>
                        <p><strong>Beweis.</strong>
                            Die Beweismethode ist vielleicht neu für Sie, aber in der Komplexitätstheorie und
                            Kombinatorik
                            sehr wichtig. Wir stellen uns zwei <em>Zählaufgaben</em>: (1) wie viele Boolesche
                            Funktion $f : \fcube$ gibt es? (2) Wie viele Boolesche Schaltkreise
                            mit $n$ Input-Variablen, Fan-in 2 und $s$ Gates gibt es?
                            Wenn die Antwort auf (2) kleiner ausfällt als auf (1), dann können nicht alle
                            Booleschen Funktionen mit $n$ Variablen einen Schaltkreis mit weniger als $s$ Gates haben.
                            Es gibt einfach nicht genug für alle. Dahinter steht folgende Beobachtung: zwei verschiedene
                            Boolesche Funktionen brauchen verschiedene Schaltkreise; sie können sich nicht einen
                            "teilen" (dieses Behauptung erscheint trivial und ist es auch; machen Sie sich aber klar,
                            dass wir diese Eigenschaft benötigen, falls Sie nämlich ein Abzählargument in anderen
                            Kontexten
                            anwenden).
                        </p>

                        <p>
                            Die Antwort auf (1) ist einfach: es gibt genau $2^{2^n}$ Boolesche Funktionen
                            mit $n$ Variablen. Warum? Die Wahrheitstabelle hat $2^n$ Zeilen. Sie könnne sich
                            also $2^n$ mal für $0$ oder $1$ entscheiden.
                        </p>

                        <div class='well container-fluid subtheorem'>
                            <p><span class='numbered-title'>Behauptung</span> Sei $s \geq n \geq 1$. Dann gibt es
                                höchstens
                                $s^{2s+1}$ Schaltkreise mit $n$ Input-Variablen, Fan-in 2 und $s$ Gates. </p>
                        </div class='well container theorem'>
                        <div class='well container-fluid'>
                            <p><strong>Beweis.</strong>
                                Wir bauen den Schaltkreis, indem wir erst einmal $s$ Gates unbeschriftet "hinmalen".
                                Um nun zu entscheiden, was für ein Schaltkreis das sein soll, müssen wir Entscheidungen
                                treffen:
                            </p>
                            <ol>
                                <li>Für jedes der $s$ Gates, was es sein soll.
                                    <ul>
                                        <li>Ein Input-Gate? Dann müssen wir es
                                            mit einer der $n$ Input-Variablen beschriften.</li>
                                        <li> Ein Not-Gate? Dann müssen wir eines der anderen Gates
                                            als Vorgänger-Gate wählen. Wir haben höchstens $s-1$ Möglichkeiten.
                                        </li>
                                        <li> Ein And-Gate? Dann müssen wir zwei der anderen Gates als
                                            Vorgänger-Gates wählen. Wir haben höchstesn ${s-1 \choose 2} =
                                            \frac{(s-1)(s-2)}{2}$ Möglichkeiten.
                                        </li>
                                        <li> Ein Or-Gate? Dann haben wir auch höchstens ${s-1 \choose 2}$ Möglichkeiten.
                                        </li>
                                    </ul>
                                    <p>
                                        Insgesamt haben wir also
                                        $$
                                        n + (s-1) + 2 {s-1 \choose 2} = n + s - 1 + (s-1)(s-2) =
                                        n + s^2 - 2s + 1 \leq s^2
                                        $$
                                        Möglichkeiten.
                                    </p>
                                </li>
                                <li>
                                    Für den gesamten Schaltkreis: welches Gate Output-Gate sein soll. Da haben
                                    wir $s$ Möglichkeiten.
                                </li>
                            </ol>
                            <p>
                                Um die Gesamtzahl der Möglichkeiten abzuschätzen, müssen wir das alles multiplizieren.
                                Wir haben höchstens
                            </p>
                            $$
                            \underbrace{s}_{\textnormal{Output-Gate wählen}} \cdot \underbrace{\prod_{i=1}^s
                            (s^2)}_{\textnormal{jedes Gate beschriften}}
                            = s \cdot (s^2)^s = s^{2s+1}
                            $$
                            Möglichkeiten. Es gibt also höchstens $s^{2s+1}$ verschiedene Schaltkreise mit $s$ Gates,
                            Fan-in 2 und $n$ Variablen.
                            <span class='qed'>\(\square\)</span>
                        </div class='proof'>
                        <p>
                            Wählen wir nun $s := 2^{n} / (2n)$. Wieviele Schaltkreise mit $n$ Variablen, Fan-in 2 und
                            $s$ Gates gibt es? Die Schranke in der obigen Behauptung sagt, dies seien höchstens
                        </p>
                        \begin{align*}
                        \pfrac{2^n}{2n}^{\frac{2^{n}}{n} + 1} & = \left(2^{n - \log (2n)}\right)^{\frac{2^n}{n} + 1} \\
                        & = 2^{2^{n} + n - \log(2n) \frac{2^{n}}{n} - \log (2n)} \\
                        & \lt 2^{2^n} \ .
                        \end{align*}
                        <p>
                            Also: es gibt mehr Boolesche Funktionen in $n$ Variablen, als es Boolesche Schaltkreise
                            mit $\frac{2^n}{2n}$ Gates gibt. Somit benötigen manche Boolesche Funktionen
                            mehr als $\frac{2^n}{2n}$ Gates.

                            <span class='qed'>\(\square\)</span>
                        </p>
                    </div class='proof'>

                    <div class='well well-lg numbered-exercise container'>
                        <p><span class='numbered-title'>Übungsaufgabe</span>
                            In Theorem und Beweis sprechen wir die ganze Zeit nur von Schaltkreisen
                            mit Fan-in 2. Was geschieht, wenn wir beliebigen Fan-in erlauben?
                            Wie ändern sich Aussage und Beweis?
                        </p>
                        <p>
                            Was geschieht, wenn wir weitere Gates, z.B. $\oplus$ als atomare
                            Gates zulassen?
                        </p>
                    </div class='numbered-exercise'>

                    <p>
                        Der obige Beweis sagt noch mehr: der Anteil Boolescher Funktionen, bei denen wir mit
                        $\frac{2^n}{2n}$ Gates auskommen, ist verschwindend klein. Fast <em>alle</em> Funktionen
                        brauchen also riesige Schaltkreise. In einem Gewissen Sinne haben wir also einfach Glück:
                        die Funktionen, die uns interessieren, wie $n$-Bit-Addition, Majority, Parity und so weiter,
                        haben einfach niedrige Komplexität. Das liegt wohl in der Natur der Sache: wir addieren,
                        multiplizieren,
                        bauen Brücken, Häuser, Flugzeuge, Computer, weil wir es <em>können</em>, weil also die dafür
                        benötigten Berechnungen effizient durchführbar sind.
                    </p>

                    <div class='well container subtheorem'>
                        <p><span class='numbered-title'>Forschungsprojekt.</span> Finde eine konkret
                            beschreibbare Funktion $f: \fcube$, die exponentiell viele (oder zumindest superpolynomiell
                            viele)
                            Gates benötigt.</p>
                    </div class='well container subtheorem'>

                    <p>
                        Kandidaten für solche Funktionen gibt es viele. Im Prinzip gibt uns jedes
                        Entscheidungsproblem, dass für eine "schwierige" Komplexitätsklasse vollständig
                        ist, einen Kandidaten. Also zum Beispiel Graphenfärbbarkeit.
                    </p>
                    <div class='well container subtheorem'>
                        <p><span class='numbered-title'>Entscheidungsproblem 3-Färbbarkeit.</span> Gegeben
                            ein Graph $G = (V,E)$, gibt es eine Funktion </p>
                        \begin{align*}
                        c : V \rightarrow \{\textnormal{rot, grün, blau}\} \ ,
                        \end{align*}
                        <p>
                            so dass $c(u) \ne c(v)$ für alle $\{u,v\} \in E$ gilt? Dass also benachbarte Knoten
                            verschiedene Farben bekommen?
                        </p>
                    </div class='well container subtheorem'>
                    <p>
                        3-Färbbarkeit ist ein zentrales NP-vollständiges Problem. Wir vermuten also, dass es dafür
                        keinen polynomiellen Algorithmus gibt. Wir können es zur Zeit (April 2024) aber nicht beweisen.
                        Dies ist das berühmte Problem P vs NP, von dem Sie sicher schon gehört haben und das als
                        eines der großen offenen Probleme der Mathematik insgesamt gilt. Die
                        Frage, ob NP-Probleme polynomiell große Schaltkreise haben, ist noch offener.
                    </p>

                    <div class='well well-lg numbered-exercise container'>
                        <p><span class='numbered-title'>Übungsaufgabe</span>
                            Formal gesehen ist Graphenfärbbarkeit eine Sprache
                            $L \subseteq \Sigma^*$ über einem Alphabet $\Sigma$, dass uns
                            erlaubt, Graphen zu codieren. Wie können wir $L$ als Boolesche Funktion darstellen?
                        </p>
                    </div class='numbered-exercise'>


                    <h3>Obere Schranken: Die Lupanov-Schranke</h3>

                    <p>
                        Wir haben nun eine Konstruktion, die uns für jede beliebige
                        Funktion $f: \fcube$ Schaltkresie mit $O(2^n)$ Gates baut.
                        Wir haben eine untere Schranke, die besagt, dass es mit weniger
                        als $\frac{2^{n}}{2n}$ Gates nicht geht. Diese beiden Schranken lassen
                        aber immer noch eine Lücke der Größenordnung $n$. Können wir sie schließen?
                    </p>

                    <div class='well container theorem'>
                        <p><span class='numbered-title'>Theorem</span> <strong>(Lupanov)</strong>. Für jede Boolesche
                            Funktion in $n$ Variablen gibt es einen Schaltkreis mit Fan-in 2 und $O(2^n / n)$ Gates.</p>
                    </div class='well container theorem'>
                    <div class='well container'>
                        <p><strong>Beweis.</strong>
                            Der Beweis fußt auf zwei Kernideen: erstens bauen wir den Schaltkreis nicht
                            mit AND- und OR- und NOT-Gates, sondern mit AND- und XOR-Gates. Da wir
                            nach vollendeter Konstruktion jedes XOR-Gates durch einen kleinen Schaltkreis
                            aus vier AND/OR/NOT-Gates ersetzen können, spielt dies keine Rolle (der Faktor
                            4 verschwindet in der $O$-Notation).
                        </p>
                        <p>
                            Die zweite Idee ist, dass wir anstreben, für
                            eine bliebige Menge $F$ an Booleschen Funktionen einen "überraschend guten"
                            Schaltkreis zu bauen, der jede Funktion $f \in F$ berechnet. Dieser Schaltkreis
                            wird $|F|$ Output-Gates haben, und seine Größe wird auch von $|F|$ abhängen.
                        </p>

                        <p><strong>$\F_2$-Polynome.</strong> Polynome in mehreren Variablen kennen Sie
                            sicherlich: zum Beispiel $xyz + xy + 1 + y$. Der Unterschied hier ist nur,
                            dass wir alle Werte modulo 2 auswerten, also in dem endlichen Körper
                            $\F_2$ arbeiten. Wir brauchen daher auch keine höheren Potenzen:
                            $x^2$ und $x$ ergeben für alle $x \in \{0,1\}$ die gleichen Werte.
                            Wenn wir in $\F_2$ rechnen, können wir uns also auf <em>multilineare</em>
                            Polynome beschränken. Führen wir Polynome formal ein:
                            wir haben eine Menge $x_1, \dots, x_n$ von Variablen;
                            ein Monom in diesem Variablen ist ein Produkt aus Variablen, also
                            $\prod_{i \in I} x_i$ für eine Menge $I \subseteq [n]$.
                            Wir schreiben das kurzerhand als $\x^I$. Ein Polynom ist nun eine
                            Summe von Monomen: $\x^{I_1} + \x^{I_2} + \dots + \x^{I_t}$.
                            Beachten Sie, dass wir vor den Monomen keine Koeffizienten brauchen, da es
                            als Konstanten eh nur 0 und 1 gibt.
                            Ein Polynom $p(\x)$ berechnet eine Boolesche Funktion $\fcube$.
                        </p>

                        <div class='well well-lg numbered-exercise container-fluid'>
                            <p><span class='numbered-title'>Übungsaufgabe</span>
                                Zeigen Sie, dass sich jede Boolesche Funktion $f$
                                als $\F_2$-Polynom schreiben lässt.
                            </p>
                            <p>
                                <strong>Tipp:</strong> beschränken Sie sich zuerst auf Funktionen $f$,
                                deren Wahrheitstabelle in genau einer Zeile eine 1 haben. Schreiben
                                Sie eine solche Funktion als $\F_2$-Polynom.
                            </p>
                        </div class='numbered-exercise'>

                        <p>Wann sind zwei Polynome gleich? Wenn sie die gleichen Monome haben (mit
                            gleichen Koeffizienten, aber die spielen hier ja keine Rolle).
                            Wir würden also sagen, dass
                            $xyz + x$ und $x + yzx$ die gleichen Polynome sind.
                            Dagegen wären $x^2yz + x$ und $xyz+x$ <em>verschiedene</em> Polynome.
                            Da wir über $\F_2$ arbeiten, beschränken wir uns aber eh auf multilineare Polynome,
                            wo also alle Exponenten 1 sind.
                        </p>

                        <div class='well well-lg numbered-exercise container'>
                            <p><span class='numbered-title'>Übungsaufgabe</span>
                                Zeigen Sie, dass sich jede Funktion $f :\fcube$ <em>eindeutig</em>
                                als multilineares $\F_2$-Polynom schreiben lässt. In anderen Worten:
                                wenn $p$ und $q$ zwei verschiedene multilineare Polynome sind, dann
                                berechnen sie verschiedene Funktionen.
                            </p>
                        </div class='numbered-exercise'>

                        <p>
                            Ein $\F_2$-Polynom können wir natürlich ganz einfach als
                            Schaltkreis mit AND- und XOR-Gates schreiben. AND für die Multiplikation
                            und XOR für die Addition in $\F_2$. Dies ist also die erste Kernidee: wir
                            arbeiten mit AND und XOR und somit mit $\F_2$-Polynomen. Wieviele Gates
                            brauchen wir dafür?
                        </p>
                        <p>
                            Schreiben wir $f = \x^{I_1} + \x^{I_2} + \dots + \x^{I_t}$.
                            Ein Monom $\x^{I}$ können wir mit $|I|-1$ AND-Gates berechnen.
                            Die Summe bilden wir mit $t-1$ weiteren XOR-Gates. Da
                            $t \leq 2^n$ und $|I| \leq n$ gilt, brauchen wir maximal
                        </p>
                        \begin{align*}
                        (n-1) 2^n + 2^n - 1 \leq n 2^n
                        \end{align*}
                        <p>
                            Gates. Allerdings ist das eine ungenaue Rechnung: Selbst wenn <em>alle</em>
                            $2^n$ Monome vertreten sind, bestehen nicht alle Monome aus $n$ Variablen.
                        </p>
                        <div class='well well-lg numbered-exercise container'>
                            <p><span class='numbered-title'>Übungsaufgabe</span>
                                Rechnen Sie genauer! Wenn Sie alle Monome berechnen wollen,
                                brauchen Sie
                            </p>
                            \begin{align*}
                            \sum_{I \subseteq [n]} (|I| - 1)
                            \end{align*}
                            <p>
                                viele AND-Gates. Finden Sie eine geschlossene Formel für diesen Ausdruck.
                            </p>
                        </div class='numbered-exercise'>
                        <p>
                            Als nächstes wollen wir zeigen, wie man $f$ mit höchstens $2^n$
                            AND-Gates und $2^n-1$ XOR-Gates berechnet. Wir zeigen in der Tat
                            etwas mehr:
                        </p>
                        <div class='well container-fluid theorem'>
                            <p><span class='numbered-title'>Lemma</span> Es gibt einen
                                Schaltkreis $C_n$ mit $n$ Input-Gates $x_1,\dots,x_n$ und
                                $2^n$ Output-Gates, eines für jedes Monom $x^{I}$, der
                                $2^n$ Gates hat.</p>
                            <figure>
                                <img src='../img/circuits/all-monomials.svg' style='height:10em'>
                            </figure>
                        </div class='well container theorem'>
                        <div class='well container-fluid'>
                            <p><strong>Beweis.</strong>
                                Die Idee ist: wenn wir $x_1 x_2 x_3 x_4$ berechnen wollen,
                                brauchen wir drei AND-Gates. Allerdings müssen wir
                                $x_1 x_2 x_3$ eh berechnen, da wir ja <em>alle</em> Monome
                                wollen. Wenn wir also einen Schaltkreis für $x_1 x_2 x_3$ haben,
                                können wir daraus mit <em>einem</em> zusätzlichen AND-Gate
                                $x_1x_2x_3x_4$ berechnen.
                            </p>
                            <p>
                                Formal geht es mit Induktion über $n$. Für $n=0$ haben wir ein
                                einziges Monom, nämlich $1$, und einen Schaltkreis mit einem
                                einzigen Gate: dem Konstant-1-Gate, das gleichzeitig ein Output-Gate ist.
                                Für $n \geq 1$ bauen wir zuerst per Induktion einen Schaltkreis $C_{n-1}$,
                                der alle $2^{n-1}$ Monome $x^{I}$ für $I \subseteq [n-1]$ berechnet.
                                Um $C_n$ zu bauen, schaffen wir für jedes $I \subseteq [n-1]$
                                ein AND-Gate, das $\x^{I} \wedge x_n$ berechnet.
                            </p>
                            <figure class='centered-figure well container-fluid'>
                                <Carousel>    
                                    <img
                                        style="width:100%"
                                        src="../img/circuits/all-monomials-1.svg">
                                    <img
                                        style="width:100%"
                                        src="../img/circuits/all-monomials-2.svg">
                                </Carousel> 
                            </figure>
                            Insgesamt erhalten wir $2^n$ Gates, von denen jedes gleichzeitig ein
                            Ouptut-Gate ist.
                            <span class='qed'>\(\square\)</span>
                        </div class='proof'>

                        <p>
                            Die zweite Kernidee ist, dass Synergien auftreten, dass
                            wir die Variablen $x_1, \dots, x_n$ in einen vorderen
                            und in einen hinteren Teil aufteilen:
                            die erste $k$ Variablen $x_1,\dots, x_k$ benennen wir um
                            in $y_1, \dots, y_k$; die hinteren $n-k$ Variablen
                            $x_{n-k+1}, \dots, x_n$ in $z_1, \dots, z_n$. Wir können $f$ also
                            wie folgt schreiben:
                        </p>
                        \begin{align*}
                        f(\x) & = \sum_{I \subseteq [n]} c_I \x^I \tag{mit Koeffizienten $c_I \in \{0,1\}$} \\
                        & = \sum_{A \subseteq [n-k]} \sum_{B \subseteq [k]} c_{A,B} \y^A \z^B \\
                        & = \sum_{A \subseteq [n-k]} \y^A \left( \sum_{B \subseteq [k]} c_{A,B} \z^B\right)
                        \tag{den Faktor $\y^A$ ausklammern} \\
                        & =: \sum_{A \subseteq [n-k]} \y^A g_A(\z) \tag{der inneren Summe einen Namen geben}
                        \end{align*}
                        <p>
                            Die obige Summe beinhaltet also $2^{n-k}$ Terme von der Form
                            $\y^A g_A(\z)$. Es gibt insgesamt nur $2^{2^k}$ Polynome in den Variablen $\z$.
                            Wenn nun also $2^{n-k} \gg 2^{2^k}$ ist, werden gewisse Polynome $g_A$ mehrfach
                            auftreten, und wir können sparen. Dafür berechnen wir
                            vorsorglich <em>alle</em> Funktionen in $z_1,\dots,z_k$.
                        </p>
                        <div class='well container-fluid subtheorem'>
                            <p><span class='numbered-title'>Lemma.</span> Es gibt einen
                                Schaltkreis mit Input-Gates $z_1,\dots,z_k$ und $2^{2^k}$ Output-Gates, einen
                                für jede Funktion $g: \{0,1\}^k \rightarrow \{0,1\}$. Der Schaltkreis hat
                                Fan-in 2 und insgesamt $2^k + 2^{2^k}$ Gates (AND-Gates und XOR-Gates).
                            </p>
                        </div class='well container theorem'>
                        <div class='well well-lg numbered-exercise container-fluid'>
                            <p><span class='numbered-title'>Übungsaufgabe</span>
                                Beweisen Sie das Lemma. Konstrukieren Sie zuerst wie
                                im vorherigen Lemma einen Schaltkreis, der Ihnen alle
                                Monome berechnet.
                            </p>
                        </div class='numbered-exercise'>

                        <div class='well well-lg numbered-exercise container-fluid'>
                            <p><span class='numbered-title'>Übungsaufgabe</span>
                                Zeigen Sie, dass die obige Konstruktion verbessert werden kann, indem
                                Sie einen Schaltkreis mit nur $2^{2^k}$ Gates bauen.
                            </p>
                            <p><strong>Tip.</strong> Jedes Gate muss also gleichzeitig
                                ein Output-Gate sein.</p>
                        </div class='numbered-exercise'>

                        <p>
                            Wenn wir nun einen Schaltkreis haben, der uns jedes
                            $g : \{0,1\}^k \rightarrow \cube$ berechnet, schauen wir uns
                            wieder $f(\x)$ an.
                        </p>
                        \begin{align*}
                        f(\x) & =
                        \sum_{A \subseteq [n-k]} \y^A g_A(\z)
                        \end{align*}
                        <p>
                            Für jedes $g_A$ haben wir ja bereits ein Gate, das es berechnet.
                            Mit einem weiteren Schaltkreis von $2^{n-k}$ Gates können wir alle
                            Monome $\y^A$ berechnen. Schlussendlich müssen wir noch die Summe
                            $\sum_{A \subseteq [n-k]}$ bilden, wofür wir $2^{n-k}$ XOR-Gates brauchen.
                            Insgesamt brauchen wir also
                        </p>
                        \begin{align}
                        & \underbrace{2^{2^k} + 2^k}_{\textnormal{für alle $g: \cube^k \rightarrow \cube$}}
                        +
                        \underbrace{2^{n-k}}_{\textnormal{für alle Monome $\y^A$}}
                        +
                        \underbrace{2^{n-k}}_{\textnormal{um $\y^A$ und $g_A(\z)$ zu multiplizieren}}
                        +
                        \underbrace{2^{n-k}-1}_{\textnormal{für die Summe $\sum_{A \subseteq [n-k]}$}}
                        \nonumber \\
                        = &
                        2^{2^k} + 3 \cdot 2^{n-k} + 2^k - 1 \ .
                        \label{size-lupanov}
                        \end{align}
                        <p>
                            Wir müssen nun $k$ so wählen, dass der obige Ausdruck minimiert wird.
                            Anstatt nun abzuleiten und gleich 0 zu setzen, verwenden wir einen
                            Faulheitstrick, der funktioniert, wenn Sie das Minimum nur ungefähr haben wollen:
                            wir setzen $k$ so, dass die beiden großen Ausdrücke -
                            $2^{2^k}$ und $2^{n-k}$ ungefähr gleich sind. Das gibt nicht das
                            präzise Minimum, aber sicherlich eine gültige Konstruktion und somit eine
                            obere Schranke.
                        </p>
                        \begin{align*}
                        2^{2^k} & = 2^{n-k} \qquad \Leftrightarrow \\
                        2^k & = n-k \qquad \Leftrightarrow \\
                        2^k +k & = n
                        \end{align*}
                        <p>
                            Ich habe keine explizite Formel, um das für $k$ aufzulösen, also
                            setze ich auf gut Glück $k = \log n$ und wir erhalten
                        </p>
                        <p style="color:red">
                            \begin{align*}
                            (\ref{size-lupanov}) & = 2^{2^k} + 3 \cdot 2^{n-k} + 2^k - 1 \\
                            & = 2^{2^{\log n}} + \dots
                            \end{align*}
                        </p>
                        <p>
                            und wir können gleich aufhören, da der erste Term bereits $2^n$ ergibt.
                            Das ist zu groß.
                            Wir müssen $k$ also kleiner wählen. Nächster Versuch: $k := \log n - 1$.
                        </p>

                        \begin{align*}
                        (\ref{size-lupanov}) & = 2^{2^k} + 3 \cdot 2^{n-k} + 2^k - 1 \\
                        & =
                        2^{2^{\log n - 1}} + 3 \cdot 2^{n - \log n + 1} + 2^{\log n - 1} - 1 \\
                        & =
                        2^{n/2} + \frac{6 \cdot 2^n}{n} + n/2 - 1 \\
                        & =
                        O\pfrac{2^n}{n} \ .
                        \end{align*}
                        <p>
                            Das ist die behauptete Schranke.<span class='qed'>\(\square\)</span>
                        </p>
                        <!--

                        <div class='well container-fluid subtheorem'>
                            <p><span class='numbered-title'>Lemma.</span><strong>(Mengenrabatt für Boolesche
                                    Funktionen</strong>).</p> Sei $F = \{f_1,\dots,f_t\}$ eine Menge
                            Boolescher Funktionen über $m$ Variablen und $p \in \N$. Dann gibt es
                            einen Schaltkreis $C_F$ mit AND- und XOR-Gates und Fan-in 2
                            mit $n$ Input-Gates und $t$ Output-Gates,
                            der insgesamt höchstens
                            </p>
                            \begin{align*}
                            2^m + \frac{2^m}{p} \cdot 2^p + \frac{t \cdot 2^m}{p}
                            \end{align*}
                            Gates hat, so dass das $i$-te Output-Gate die Funktion $f_i$ berechnet.
                        </div class='well container subtheorem'>

                        <p>
                            Zum Vergleich: wenn wir obige Konstruktion anwenden,
                            brauchen wir für ein einzelnes $f$ bis zu
                            $2^m$ AND-Gates und $2^m-1$ XOR-Gates, also $O(2^m)$.
                            Für $t$ Funktionen wären das dann $O(t 2^m)$. Das Lemma besagt also,
                            dass wir (für gut gewähltes $p$) Synergieeffekte nutzen können; dass also
                            die $t$ Funktionen $f$ in $F$ zusammen deutlich weniger kosten als die einzelnen
                            $f$ in Summe. Wir kriegen also einen Mengenrabatt.
                        </p>
                        <div class='well container-fluid'>
                            <p><strong>Beweis.</strong>
                                Wir unterteilen die Variablen $x_1,\dots,x_m$ in
                                einen vorderen Teil $\y = (x_1,\dots,x_{m-k})$ und
                                einen hinteren Teil $\z = (x_{n-k+1}, \dots, x_m)$.
                                Die Monome $x^I$ eines Polynoms können wir nun
                                schreiben als $\y^{J} \z^{K}$ und so gruppieren,
                                dass Monome mit gleichem $\y$-Teil nebeneinanderstehen und
                                diesen dann "ausklammern", also </p>
                            \begin{align*}
                            f(\x) = \sum_{J \subseteq [m-k]} \y^J f_J(\z) \ .
                            \end{align*}
                            <p>
                                Also beispielsweise für $m = 5$ und $k=2$:
                            </p>
                            \begin{align*}
                            x_1 x_4 + x_1 x_2 x_5 + x_1 x_3 + x_1 x_4 x_5 + x_1 x_2 + x_1 x_3 x_4 + x_1 x_3 x_4 x_5
                            = & 1 \cdot (0) + \\
                            & x_1 \cdot (x_4 + x_4 x_5) + \\
                            & x_2 \cdot (0) + \\
                            & x_1 x_2 \cdot (1 + x_5 ) + \\
                            & x_3 \cdot (0) + \\
                            & x_1 x_3 \cdot (1 + x_5 + x_4 x_5) + \\
                            & x_2 x_3 \cdot (0) + \\
                            & x_1 x_2 x_3 \cdot (0) \ .
                            \end{align*}
                            <p>
                                Die Summe $\sum_{J \subseteq [m-k]} x^J f_J(\z)$ summiert
                                stur über alle $2^{m-k}$ Werte, die $J$ annehmen kann;
                                die Polynome $f_J(\z)$ sind von der individuellen Funktion $f$
                                abhängig. Da $f_J$ ein Polynom in $k$ Variablen ist,
                                also eine Boolesche Funktion $\cube^k \rightarrow \cube$ berechnet,
                                gibt es $2^{2^k}$ mögliche Funktionen dafür. Wenn nun
                                $t \gg 2^{2^k}$ ist, dann ist es billiger, <em>alle</em>
                                möglichen Funktionen auf $x_{m-k+1},\dots, x_m$
                                im Voraus zu berechnen und dann für jedes konkrete $f$ die
                                bereits berechneten zu verwenden.
                            </p>
                            <div class='well container-fluid subtheorem'>
                                <p><span class='numbered-title'>Behauptung</span> Es gibt
                                    einen Schaltkreis mit $k$ Input-Variablen
                                    $x_{m-k+1},\dots,x_m$ und $2^{2^k}$ Output-Gates, eines
                                    für jede Funktion $g : \cube^k \rightarrow \cube$.
                                    Der Schaltkreis besteht aus $2^k$ AND-Gates
                                    und $2^{2^k}$ XOR-Gates.</p>
                            </div class='well container-fluid subtheorem'>
                            <div class='well container-fluid'>
                                <p><strong>Beweis.</strong>
                                    Wir bauen einen Schaltkreis mit $2^k$ AND-Gates, der
                                    uns alle $2^k$ Monome über $\z = (x_{m-k+1},\dots,x_m)$ berechnet.
                                    Bezeichnen wir diese Monome mit
                                    $\alpha_1, \dots, \alpha_{2^k}$.
                                    Jede Funktion in den Variablen $\z$ lässt sich nun
                                    als multilineares Polynom schreiben, also als Summe
                                    einer Teilmenge dieser Polynome. Wir bauen nun einen
                                    Schaltkreis mit Input-Gates $\alpha_1,\dots,\alpha_{2^k}$,
                                    der für jede Menge $A \subseteq [2^k]$ die Summe
                                </p>
                                \begin{align*}
                                \sum_{i \in A} \alpha_i
                                \end{align*}
                                <p>
                                    berechnet. Mit dem gleichen Recycling-Trick wie oben
                                    schaffen wir das mit $2^{2^k}$ XOR-Gates.
                                    <span class='qed'>\(\square\)</span>
                                </p>
                            </div class='proof'>
                            <p>
                                Wir haben also nun einen Schaltkreis der Größe
                                $2^k + 2^{2^k}$, der jede Funktion $g : \cube^k \rightarrow \cube$
                                berechnet (und somit $2^{2^k}$ Output-Gates hat).
                                Als zweites bauen wir uns einen Schaltkreis mit
                                Input-Variablen $\y = (x_1,\dots,x_{m-k})$ und $2^{m-k}$
                                Output-Gates, der alle Monome $\y^J$ berechnet.
                                Diese zwei
                                verwenden wir nun, um jedes einzelne $f \in F$ effizient
                                zu berechnen:
                            </p>
                            \begin{align}
                            f(\x) = \sum_{J\subseteq [m-k]} \y^J f_J(\z)
                            \label{f-as-sum}
                            \end{align}
                            <p>
                                Für jeden Ausdruck $\y^J f_J(\z)$ brauchen wir
                                ein AND-Gate, also $2^{m-k}$ insgesamt, und dann noch einmal
                                $2^{m-k} - 1$ XOR-Gates, um die Summe zu bilden. Insgesamt
                                brauchen wir also
                            </p>
                            \begin{align*}
                            \underbrace{2^k + 2^{2^k}}_{\textnormal{alle Funktionen über $\z$}}
                            +
                            \underbrace{2^{m-k}}_{\textnormal{alle Monome über $\y$}} +
                            t \cdot (\underbrace{2^{m-k} + 2^{m-k} -1}_{\textnormal{für die Summe in (\ref{f-as-sum})}})
                            \end{align*}

                            MARKER
                            <P>
                                Wir teilen die Variablen $x_1,\dots,x_n$ in drei Teile
                                auf: die ersten $k$, die hinteren $l$ und die mittleren $n-k-l$
                                und benennen diese um in
                                $\u = (u_1,\dots,u_k) = (x_1,\dots,x_k)$,
                                $\v = (v_1,\dots,v_{n-m-l}) = (x_{k+1}, \dots, x_{n-l})$ und
                                einen $\w = (w_1,\dots,w_l) = (x_{n-l+1,\dots, x_n})$. Ein
                                Monom $\x^I$ schreiben wir nun als $\u^A \v^B \w^C$
                                mit $A \subseteq [k]$, $B \subseteq [n-k-l]$ und $C \subseteq [l]$.
                                Die Funktion $f$ schreiben wir nun so, dass wir
                                Monome mit gleichem $\u$-Teil gruppieren und $\u^A$ ausklammern;
                                dann gleiche $\v$-Teile ausklammern:
                            </P>
                            \begin{align*}
                            f(\x) & = \sum_{I} c_I \x^I \tag{mit $c_I \in \{0,1\}$} \\
                            & = \sum_{A \subseteq [k]} \u^A \sum_{B \subseteq [n-k-l]} \v^B g_{A,B} (\w) \ .
                            \end{align*}
                            <P>
                                Die $g_{A,B}$ sind Polynome in den $l$ Variablen $w_1,\dots,w_l$.
                            </P>
                            MARKER
                            \begin{align*}
                            f(\x) & = \sum_{I} c^I \x^I \\
                            & = \sum_{J \subseteq [n-k]} \y^J f_J(\z)
                            \end{align*}
                            <p>
                                Naiv vorgehend bräuchten wir für jedes $f_J$, das ja eine
                                Funktion über $k$ Variablen ist, bis zu $2^k$ Gates. Das ganze
                                müssen wir für jedes $J$ durchführen, wovon es
                                $2^{n-k}$ gibt; also insgesamt $2^n$. Und da sind
                                die zusätzlichen XOR-Gates für die Summe noch gar nicht mitgerechnet.
                                Der Trick ist jetzt: wieviele Möglichkeiten gibt es
                                denn für $f_J$? In der obigen Summe kommen $2^{n-k}$ solcher
                                Funktion vor. Allerdings gibt es höchstens $2^{2^k}$ verschiedene.
                                Wenn nun $2^{2^k} \ll 2^{n-k}$ gilt, dann kommen
                                manche $f_J$ mehrfach vor. Es lohnt sich also, <em>alle</em>
                                Funktionen $\cube^k \rightarrow \cube$ im Voraus zu berechnen
                                und dann in der obigen Summe kostenlos wiederzuverwenden.
                                Wir brauchen $2^{2^k} + 2^k$ Gates, um alle Funktionen
                                in $\z$ zu berechnen, und dann $2^{n-k+1}-1$ weitere Gates.
                                In etwa also $2^{n-k} + 2^{2^k}$.
                                Das wird ungefähr minimiert, wenn beide Terme gleich sind,
                                also wenn $n -k = 2^k$, also ungefähr $k = \log n$. Probieren wir es
                                aus:

                            </p>
                            \begin{align*}
                            2^{2^k} + 2^{n-k} = 2^{2^{\log n}} + 2^{n-\log n}
                            = 2^n + \frac{2^n}{n} \ . \tag{für $k := \log n$}
                            \end{align*}
                            <p>
                                Das ging schief. Probieren wir $k := \log n - 1$:
                            </p>
                            \begin{align*}
                            2^{2^k} + 2^{n-k} = 2^{2^{\log n - 1}} + 2^{n-\log n + 1}
                            = 2^{n/2} + 2 \cdot \frac{2^n}{n} = O\pfrac{2^n}{n} \ .
                            \end{align*}
                            <p>

                                Bauen wir zuerst einen Schaltkreis mit $2^m$ Outputs, der alle $2^m$ Monome
                                über $x_1,\dots,x_m$ berechnet. Um ein Monom $\x^I$ zu berechnen,
                                brauchen wir $|I| \leq m-1 \leq m$ AND-Gates. Wenn wir das für jedes Monom durchführen,
                                brauchen wir höchstens $m2^m$ Gates.
                                <span class='qed'>\(\square\)</span>
                            </p>

                        </div class='proof'>
                        <p>
                            Es geht aber deutlich besser: wenn $J = I \cup \{j\}$ ist und wir
                            $\x^J$ berechnen wollen,
                            brauchen wir nicht $|J|-1$ neue AND-Gates.
                            Wir wissen ja, dass wir eh $\x^I$ berechnen müssen und können nun
                            $\x^J$ als $\x^I \wedge x_j$ mit <em>einem</em> neuen AND-Gate berechnen.
                        </p>
                        <p>
                            Formal bauen wir ein Gate $C_I$ für jedes $I \subseteq [m]$ und beschriften und
                            verknüpfen es wie folgt:
                        </p>
                        <ul>
                            <li>Wenn $|I| = 0$ ist, dann ist $C_I$ das konstante Gate $1$.</li>
                            <li>Wenn $I = \{i\}$ ist, dann ist $C_I$ das Input-Gate $x_i$.</li>
                            <li>Wenn $|I| \geq 2$, dann sei $i := \max I$ und $I' := I \setminus \{i\}$.
                                Das Gate $C_I$ ist nun ein AND-Gate mit zwei Input-Kabeln: eines
                                von $C_{I'}$ und eines von $x_i$.
                            </li>
                        </ul>
                        <p>
                            Wir erhalten also einen Schaltkreis mit genau $2^m$ Gates, wovon
                            $m$ viele Input-Gates und $2^m$ viele Output-Gates sind (ja, das Input-Gate $x_i$ ist
                            selbst ein Output-Gate, nämlich $C_{\{i\}})$.
                        </p>
                        <p>
                            Wir haben nun für jedes Monom $\x^I$ ein Gate, das es berechnet. Wir partitionieren nun
                            diese Gates / Monome in $q := \ceil{\frac{2^m}{p}}$ <em>Abschnitte</em> von jeweils maximal
                            $p$
                            Elementen. Wir können nun eine beliebige Funktion $f$ als
                            $f = f_1 \oplus f_2 \oplus \dots \oplus f_q$ schreiben, so dass $f_i$ nur Monome
                            aus Abschnitt $i$ enthält.
                        </p>
                        <span class='qed'>\(\square\)</span>
                        -->
                    </div class='proof'>

                </div class='subChapter'>

            </div class='chapter'>

        </div class="content">
    </div class="rightSideWrapper">