<div id="rightSideWrapper">
        <div class="content">
            <div class='chapter'>
                <div class='subChapter'>
                    <h1 class='hidden-title'>
                        <span class='subChapterTitle'>9.5 Reduktionen</span>
                    </h1>
                    <p>
                        <span style="font-variant: small-caps;">3-Colorability</span> und
                        <span style="font-variant: small-caps;">CNF-Satisfiability</span> sind in NP:
                        gegeben ein Graph $G$ und eine Färbung $c$, so können wir effizient feststellen,
                        ob $c$ eine gültige 3-Färbung von $G$ darstellt; gegeben eine CNF-Formel $F$ und
                        eine Belegung $\alpha$, so können wir effizient überprüfen, ob $F$ unter $\alpha$ zu
                        <tt>True</tt> auswertet. Können wir <span
                            style="font-variant: small-caps;">3-Colorability</span> und
                        <span style="font-variant: small-caps;">CNF-Satisfiability</span> auch effizient entscheiden?
                        Sind sie in P? Das ist (Stand: 2025) nicht bekannt. Was wir aber sagen können:
                        entweder sind beide effizient lösbar oder beide nicht. Sie sind gewissermaßen gleich schwer.
                    </p>

                    <div class='well container theorem'>
                        <p>
                            <span class='numbered-title' id='theorem-3-col-to-sat'
                                data-label-title='Theorem'>Theorem</span>
                            Falls <span style="font-variant: small-caps;">CNF-Satisfiability</span> in P ist, dann
                            auch <span style="font-variant: small-caps;">3-Colorability</span>.
                        </p>
                    </div class='well container theorem'>
                    <div class='well container'>
                        <p>
                            <strong>Beweis.</strong>
                            Wir nehmen an, wir hätten einen effizienten Algorithmus
                            <tt>is_satisfiable($F$)</tt>. Wir verwenden diesen, um einen Algorithmus
                            <tt>is_3_colorable</tt> zu entwerfen.
                            Sei nun $G = (V,E)$ ein Graph und $v_1, \dots, v_n$ seine Knoten. Wir
                            führen $3n$ Boolesche Variable ein:
                            $r_1, \dots, r_n, g_1, \dots, g_n, b_1, \dots, b_n$. Die Intention hierbei ist,
                            dass $r_i$ anzeigt, ob $v_i$ rot ist und so weiter.
                            Wir müssen jetzt Klauseln erschaffen, die die Aussage "das ist eine gültige 3-Färbung"
                            als CNF-Formel codieren. Wir erschaffen folgende Klauseln:
                        </p>
                        \begin{align*}
                        & (r_i \vee g_i \vee b_i) \tag{$v_i$ hat mindestens eine Farbe}\\
                        & (\bar{r}_i \vee \bar{g}_i) \wedge (\bar{r}_i \vee \bar{b}_i)
                        \wedge (\bar{g}_i \vee \bar{b}_i) \tag{$v_i$ hat nicht zwei Farben gleichzeitig}
                        \end{align*}
                        <p>
                            Dies tun wir für jedes $i$. Wir sehen nun: jede Belegung, die die obigen Klauseln
                            erfüllt, entspricht einer $3$-Färbung $c: V \rightarrow \{1,2,3\}$, und umgekehrt.
                            Nun müssen wir die Aussage <em>Kante $\{v_i,v_j\}$ ist gültig gefärbt</em> formulieren:
                        </p>
                        \begin{align*}
                        & (\bar{r}_i \vee \bar{r}_j) \tag{$v_i$ und $v_j$ sind nicht beide rot}\\
                        & (\bar{g}_i \vee \bar{g}_j) \tag{$v_i$ und $v_j$ sind nicht beide grün}\\
                        & (\bar{b}_i \vee \bar{b}_j) \tag{$v_i$ und $v_j$ sind nicht beide blau}\\
                        \end{align*}
                        <p>
                            und dann alles zusammenwerfen:
                        </p>
                        \begin{align*}
                        F:= & \quad \bigwedge_{i=1}^n \left( (r_i \vee g_i \vee b_i) \wedge(\bar{r}_i \vee \bar{g}_i)
                        \wedge
                        (\bar{r}_i \vee \bar{b}_i)
                        \wedge (\bar{g}_i \vee \bar{b}_i) \right) \wedge \\
                        & \bigwedge_{\{v_i, v_j\} \in E} \left(
                        (\bar{r}_i \vee \bar{r}_j) \wedge
                        (\bar{g}_i \vee \bar{g}_j) \wedge
                        (\bar{b}_i \vee \bar{b}_j)
                        \right)
                        \end{align*}
                        <p>
                            Es gilt nun: $G$ ist genau dann $3$-färbbar, wenn $F$ erfüllbar ist. Und hier
                            ist nun unser Code für <tt>is_3_colorable:</tt>
                        </p>
                        <pre class='listing container-fluid'>
<code>def is_3_colorable(graph):</code>
<code>    F = convert_to_CNF_formula(graph)</code>
<code>    <span class='comment'># F ist die oben beschriebene Formel mit 3n Variablen</span></code>
<code>    return is_satisfiable(F)</code></pre>
                        <p>
                            Falls Ihnen eine Funktion <tt>find_satisying_assignment</tt> zur Verfügung steht,
                            so können Sie natürlich die erfüllende Belegung direkt in eine
                            gültige 3-Färbung übersetzen. <span class='qed'>\(\square\)</span>
                        </p>
                    </div class='proof'>
                    <p>
                        Das ging recht schnell und direkt, weil die Aussagenlogik allgemein genug ist,
                        um Aussagen über endliche Objekte (hier: Graphen) effizient zu codieren.
                        Geht es auch andersrum? Wenn uns eine Funktion <tt>is_3_colorable</tt>
                        zur Verfügung steht, können wir dann auch eine Funktion
                        <tt>is_satisfiable</tt> schreiben?
                    </p>
                    <p>
                        Wir machen einen Zwischenschritt und schreiben mithilfe von
                        <tt>is_3_colorable</tt> einen effizienten Algorithmus
                        für $3$-SAT; dies ist <span style="font-variant: small-caps;">CNF-Satisfiability</span> mit
                        der Einschränkung, dass $F$ eine $3$-CNF-Formel ist, dass also jede Klausel nur drei Literale
                        enthält.
                        Beachten Sie, dass die Formel $F$, die wir im Beweis
                        von <span class='reference' data-ref='theorem-3-col-to-sat'></span>
                        erstellt haben, eine solche 3-CNF ist.
                    </p>
                    <div class='well container theorem'>
                        <p>
                            <span class='numbered-title' id='theorem-3-sat-to-3-col'
                            data-label-title='Theorem'>Theorem</span>
                            Falls <span style="font-variant: small-caps;">3-Colorability</span> in P ist, dann
                            auch
                            <span style="font-variant: small-caps;">3-SAT</span>.
                        </p>
                    </div class='well container theorem'>
                    <div class='well container'>
                        <p>
                            <strong>Beweis.</strong>
                            Wir gehen konzeptuell ähnlich vor wie oben. Uns ist eine 3-CNF-Formel $F$
                            gegeben. Wir müssen jetzt einen Graphen $G = (V,E)$ bauen,
                            der die Aussage <em>$F$ ist erfüllbar</em> irgendwie in seiner
                            3-Färbbarkeit oder eben Nicht-3-Färbbarkeit codiert. Dies ist schwieriger.
                        </p>
                        <p>
                            Als ersten Schritt legen wir fest, dass die drei Farben nicht $1, 2, 3$ sein sollen,
                            sondern <tt>True, False, Neutral</tt>.
                        </p>
                        <figure class='centered-figure well container-fluid'>
                            <a class='left carousel-control-prev-icon' href='#3-sat-to-3-col' data-slide='prev'>
                                <div class='carousel-nav-icon'>
                                    <img src='../img/carousel-prev-icon.svg'>
                                </div>
                            </a>
                            <a class='right carousel-control-next-icon' href='#3-sat-to-3-col' data-slide='next'>
                                <div class='carousel-nav-icon'>
                                    <img src='../img/carousel-next-icon.svg'>
                                </div>
                            </a>
                            <div id='3-sat-to-3-col' class='carousel' data-interval='false'
                                style='display:inline-block;width:100%'>
                                <ol class='carousel-indicators'>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='1' class='active'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='2'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='3'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='4'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='5'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='6'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='7'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='8'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='9'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='10'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='11'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='12'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='13'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='14'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='15'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='16'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='17'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='18'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='19'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='20'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='21'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='22'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='23'></li>
                                    <li data-target='#3-sat-to-3-col' data-slide-to='24'></li>
                                </ol>
                                <div class='carousel-inner' style='display:inline-block'>
                                    <div class='item active'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-01.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-02.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-03.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-04.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-05.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-06.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-07.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-08.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-09.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-10.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-11.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-12.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-13.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-14.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-15.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-16.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-17.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-18.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-19.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-20.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-21.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-22.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-23.svg'
                                            style='width:100%'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/sat-to-col/sat-to-col-01-24.svg'
                                            style='width:100%'></div>
                                </div class='carousel-inner'>
                            </div class='carousel'>
                        </figure>
                        <p>
                            Wir wiederholen die beschriebene Konstruktion für jede Klausel in $F$.
                            Wir erhalten einen Graphen $G$, der genau dann $3$-färbbar ist, wenn
                            $F$ erfüllbar ist. Auch können wir direkt eine gültige $3$-Färbung in eine
                            erfüllende Belegung übersetzen und umgekehrt. Hier ist also der Code:
                        </p>
                        <pre class='listing container-fluid'>
<code>def is_3CNF_satisfiable(the_3_cnf_formula):</code>
<code>    G = convert_to_graph(the_3_cnf_formula)</code>
<code>    <span class='comment'># G ist der oben konstruierte Graph</span></code>
<code>    return is_3_colorable(G)</code></pre>
                        <span class='qed'>\(\square\)</span>
                    </div class='proof'>
                    <p>
                        Wir haben also gezeigt, wie man eine $3$-CNF $F$ in einen Graphen $G$ umwandelt, so dass
                    </p>
                    \begin{align*}
                    F \textnormal{ ist erfüllbar } \Longleftrightarrow G \textnormal{ ist $3$-färbbar}
                    \end{align*}
                    <p>
                        gilt. Allerdings ging das nur unter der Annahme, dass $F$ eine $3$-CNF ist.
                        Wie verhält es sich, wenn $F$ eine allgemeine CNF-Formel ist?
                    </p>

                    <div class='well container theorem'>
                        <p>
                            <span class='numbered-title' id='theorem-sat-to-3-sat'
                                data-label-title='Theorem'>Theorem</span>
                            Es gibt einen effizienten Algorithmus, der als Input eine CNF-Formel $F$ nimmt und eine
                            3-CNF-Formel $F'$ ausgibt, so dass gilt:
                        </p>
                        \begin{align*}
                        F \textnormal{ ist erfüllbar } \Longleftrightarrow F' \textnormal{ ist erfüllbar } \ .
                        \end{align*}
                        Falls es einen effizienten Algorithmus für $3$-SAT gibt, dann also auch einen
                        für CNF-SAT.
                    </div class='well container theorem'>
                    <div class='well container'>
                        <p>
                            <strong>Beweis.</strong>
                            Wir starten mit $F_0 := F$ und definieren eine Folge $F_0, F_1, \dots$ von
                            CNF-Formeln. Sei $F_i$ die derzeit letzte erzeugte CNF-Formel.
                            Falls $F_i$ eine Klausel $C$ mit vier oder mehr Literalen enthält,
                            führen wir eine Operation durch, die $C$ durch zwei neue, kleinere Klauseln ersetzt:
                            sei
                        </p>
                        \begin{align*}
                        C = (u_1 \vee u_2 \vee u_3 \vee u_4 \vee \dots \vee u_k)
                        \end{align*}
                        <p>
                            mit $k \geq 4$. Wir führen eine neue, bisher nicht verwendete Variable $z$ ein und
                            erschaffen die Klauseln
                        </p>
                        \begin{align*}
                        C_1 := (\bar{z} \vee u_1 \vee u_2) \\
                        C_2 := (z \vee u_3 \vee \dots \vee u_k)
                        \end{align*}
                        <p>
                            Wir entfernen nun $C$ und fügen $C_1$ und $C_2$ ein und erhalten eine neue CNF-Formel
                            $F_{i+1}$.
                            Wir sehen nun: wenn $\alpha$ die Formel $F_{i+1}$ erfüllt, dann erfüllt sie auch
                            $F_i$; umgekehrt wenn die Belegung $\beta$ die Formel $F_i$ erfüllt, dann erfüllt
                            $\beta$ insbesondere $C$; wir bauen nun eine
                            neue Belegung, die auch $z$ einen Wert zuweist und dann $C_1$ und $C_2$
                            erfüllt: falls (1) $\beta$ die Klausel $(u_1 \vee u_2)$ erfüllt,
                            dann setzen wir $z$ auf $1$, also $\alpha := \beta \cup [z \mapsto 1]$.
                            Die Belegung $\alpha$ erfüllt nun $C_1$, weil $\beta$ das bereits tut,
                            und $C_2$, weil $\alpha(z)=1$ ist;
                            falls jedoch (2) $\beta$ die Klausel $(u_1 \vee u_2)$ nicht erfüllt,
                            dann muss sie, da sie ja $C$ erfüllt, die Klausel $(u_3 \vee \dots \vee u_k)$
                            erfüllen und erfüllt somit $C_2$, auch ohne Verwendung von $z$.
                            Wir setzen nun $z$ auf $0$, also $\alpha := \beta \cup [z \mapsto 0]$ und
                            erfüllen sowohl $C_1$ als auch $C_2$.
                            Alle anderen Klauseln sind sowieso erfüllt,
                            weil $\beta$ sie bereits erfüllt. Wir sehen:
                        </p>
                        \begin{align*}
                        F_i \textnormal{ ist erfüllbar } \Longleftrightarrow F_{i+1} \textnormal{ ist erfüllbar } \ .
                        \end{align*}
                        <p>
                            Die beiden neuen Klauseln $C_1$ und $C_2$ sind jeweils echt kleiner als $C$. Der Prozess
                            endet irgendwann mit einer Formel $F_t$, in der jede Klausel höchstens drei Literale
                            hat. Dies ist unser $F'$.
                            <span class='qed'>\(\square\)</span>
                        </p>

                    </div class='proof'>

                    <p>
                        Wir haben nun also eine Kette von Implikationen erschaffen:
                    </p>
                    <ul>
                        <li>
                            Wenn <span style="font-variant: small-caps;">CNF-Satisfiability</span> in P,
                            dann auch <span style="font-variant: small-caps;">3-Colorability</span>
                            (<span class='reference' data-ref='theorem-3-col-to-sat'></span>).
                        </li>
                        <li>
                            Wenn <span style="font-variant: small-caps;">3-Colorability</span> in P,
                            dann auch <span style="font-variant: small-caps;">3-SAT</span>
                            (<span class='reference' data-ref='theorem-3-sat-to-3-col'></span>).
                        </li>
                        <li>
                            Wenn <span style="font-variant: small-caps;">3-SAT</span> in P,
                            dann auch
                            <span style="font-variant: small-caps;">CNF-Satisfiability</span>
                            (<span class='reference' data-ref='theorem-sat-to-3-sat'></span>).
                        </li>
                    </ul>
                    <p>
                        Beachten Sie, dass alle Beweise eine ähnliche Form haben: um die Aussage
                        <em>wenn $L_1 \in P$, dann auch $L_2 \in P$</em> zu zeigen, nehmen wir
                        eine beliebiges $x \in \Sigma_1$ (eine $L_1$-Instanz) und wandeln es
                        um in ein $y \in \Sigma_2$ (eine $L_2$-Instanz), so dass
                    </p>
                    \begin{align*}
                    x \in L_1 \Longleftrightarrow y \in L_2
                    \end{align*}
                    <p>
                        garantiert ist. Wenn es also einen effizienten Algorithmus <tt>is_in_L2</tt> gibt, dann
                        können wir mit folgendem Code auch $L_1$ effizient entscheiden:
                    </p>
                    <pre class='listing container'>
<code>def is_in_L1(x):</code>
<code>    y = convert_from_L1_instance_to_L2_instance(x)</code>
<code>    return is_in_L2(y)</code></pre>
                    <p>
                        Dies ist eine <em>Reduktion</em>, wie wir sie schon
                        in <span class='reference' data-ref='definition-reduction'></span> kennengelernt haben,
                        nun aber mit einer Aussage über die Laufzeit.
                    </p>
                    <div class='well container theorem'>
                        <p>
                            <span class='numbered-title' id='definition-polynomial-reduction'
                                data-label-title='Definition'>Definition
                            </span>
                            <strong>(Polynomialzeitreduktion)</strong>. Seien
                            $L_1 \subseteq \Sigma_1^*$ und $L_2 \subseteq \Sigma_2^*$ zwei
                            Sprachen. Eine Funktion $f: \Sigma_1^* \rightarrow \Sigma_2^*$ heißt
                            <em>Polynomialzeitreduktion von $L_1$ auf $L_2$</em> wenn
                        </p>
                        \begin{align*}
                        \forall x \in \Sigma_1^*: \quad x \in L_1
                        \Longleftrightarrow f(x) \in L_2
                        \end{align*}
                        <p>
                            und $f$ in Zeit $\poly(n)$ berechnet werden kann. Wenn es
                            also ein Polynom $p: \N \rightarrow \N$ und eine Turingmaschine
                            $M$ mit Eingabealphabet $\Sigma_1$ und Ausgabealphabet $\Sigma_2$
                            gibt, die Laufzeit $p$ hat und $f$ berechnet.
                        </p>
                        <p>
                            Wir schreiben dann $L_1 \leq_p L_2$.
                        </p>
                    </div class='well container theorem'>

                    <p>
                        Wenn wir eine Reduktion von $L_1$ auf $L_2$ haben und einen
                        effizienten Algorithmus für $L_2$, dann können wir
                        wie in <tt>is_in_L1(x)</tt> oben skizziert $L_1$ effizient
                        entscheiden. Formal:
                    </p>

                    <div class='well container theorem'>
                        <p>
                            <span class='numbered-title' id='prop-reduction-target-in-P'
                                data-label-title='Beobachtung'>Beobachtung</span> Wenn
                            $L_1 \leq_p L_2$ ist und $L_2 \in {\rm P}$, dann
                            auch $L_1 \in {\rm P}$.
                        </p>
                    </div class='well container theorem'>
                    <p>
                        Wir haben die folgenden Polynomialzeitreduktionen bereits kennengelernt:
                    </p>
                    <ol>
                        <li><span style="font-variant: small-caps;">3-Colorability $\leq_p$ CNF-Satisfiability</span>
                        </li>
                        <li><span style="font-variant: small-caps;">CNF-Satisfiability $\leq_p$ 3-SAT</span></li>
                        <li><span style="font-variant: small-caps;">3-SAT $\leq_p$ 3-Colorability</span></li>
                    </ol>

                    <p>
                        Erinnern Sie sich an <span style="font-variant: small-caps;">Independent Set</span>: gegeben
                        ein Graph $G$ und eine Zahl $k$, gibt es eine unabhängige Menge $X \subseteq V$ mit
                        $|X| \geq k$?
                    </p>
                    <div class='well container theorem'>
                        <p>
                            <span class='numbered-title' id='put-unique-name-here'
                                data-label-title='Theorem'>Theorem</span>
                            <span style="font-variant: small-caps;">3-SAT $\leq_p$ Independent Set</span>.
                        </p>
                    </div class='well container theorem'>
                    <div class='well container'>
                        <p>
                            <strong>Beweis.</strong>
                            Gegeben sei eine 3-CNF-Formel $F$ mit $n$ Variablen und $m$ Klauseln. Wir
                            bauen folgenden Graphen $G$:
                        </p>
                        <figure>
                            <img src='../img/09-complexity-theory/sat-to-independent-set/3sat-to-IS.svg'
                                style='height:20em'>
                        </figure>
                        <p>
                            und setzen $k:=n+m$. Wir müssen nun folgendes zeigen:
                        </p>
                        \begin{align*}
                        F \textnormal{ ist erfüllbar} \Longleftrightarrow
                        G \textnormal{ hat eine unabhängige Menge der Größe $k$}
                        \end{align*}
                        <p>
                            Falls $\alpha$ eine erfüllende Belegung von $F$ ist,
                            dann gibt es folgende unabhängige Menge der Größe $k$:
                        </p>
                        <ul>
                            <li>
                                Für jede Variable $x$ nehmen wir $x$ in $I$ auf, falls $\alpha(x)=1$ ist,
                                ansonsten $\bar{x}$.
                            </li>
                            <li>
                                Für jede Klausel $C = (u \vee v \vee w)$ gibt es ein erfülltes Literal,
                                sagen wir $u$. Dieser entspricht dem Klauselknoten $u_C$, der mit
                                mit dem Literalknoten $\bar{u}$ verbunden.
                                Da $\alpha(u) = 1$ und $\alpha(\bar{u}) = 0$ ist, ist $u \not \in I$ und
                                wir können $u_C$ in $I$ aufnehmen.
                            </li>
                            <li>
                                Unsere Menge $I$ enthält $n$ Literalknoten und $m$ Klauselknoten,
                                also insgesamt $k$ Knoten.
                            </li>
                        </ul>
                        <p>
                            Für die Gegenrichtung nehmen wir an, dass $I$ eine unabhängige Menge von $G$ ist und $|I| =
                            n+m$ gilt. Da $I$ pro Literalpaar und pro Klauseldreieck höchstens
                            einen Knoten enthalten kann, enthält $I$ <em>genau</em> einen
                            pro Literalpaar und Klauseldreieck. Wir definieren nun eine
                            Belegung $\alpha$ wie folgt: wenn für eine Variable $x$ der
                            Literalknoten $x$ in $I$ ist, setzen wir $\alpha(x)=1$; falls
                            $\bar{x}$ in $I$ ist, setzen wir $\alpha(x)=0$.
                        </p>
                        <p>
                            Wir behaupten nun, dass $\alpha$ die Formel $F$ erfüllt. Sei
                            $C= (u \vee v \vee w)$ eine beliebige Klausel von $F$.
                            Nach obiger Überlegung enthält $I$ genau einen Klauselknoten von $C$,
                            sagen wir $u_C$. Das heißt somit, dass der Literalknoten
                            $\bar{u}$ nicht in $I$ ist - sonst wäre $I$ ja nicht unabhängig.
                            Somit muss $u \in I$ gelten und $\alpha(u) = 1$, und $\alpha$ erfüllt $C$.
                            <span class='qed'>\(\square\)</span>
                        </p>
                    </div class='proof'>

                    <div class='well well-lg numbered-exercise container'>
                        <p>
                            <span class='numbered-title' id='put-unique-name-here'
                                data-label-title='Übungsaufgabe'>Übungsaufgabe</span>
                            Zeigen Sie <span style="font-variant: small-caps;">Independent Set $\leq_p$ SAT</span>.
                            Also: Gegeben einen Graphen $G$ und eine Zahl $k \in \N$, zeigen Sie, wie man die Aussage
                            <em>$G$ hat eine unabhängige Menge der Größe $k$</em> als aussagenlogische Formel
                            in CNF darstellen kann.
                        </p>
                        <p>
                            <strong>Hinweis:</strong> Die Aussage <em>"$I$ ist eine unabhängige Menge von $G$</em> ist
                            leicht darzustellen als CNF-Formeln. Die Aussage <em>"$I$ hat Größe $k$"</em> ist
                            schwieriger. Sie müssen quasi <em>zählen</em>.
                        </p>
                    </div class='numbered-exercise'>
                    <h3><span style="font-variant: small-caps;">Hamilton Path</span>
                        und <span style="font-variant: small-caps;">Hamilton Cycle</span></h3>

                    <p>
                        Sei $G = (V,E)$ ein Graph. Ein <em>Hamiltonscher Kreis</em> ist ein
                        Kreis, der durch alle Knoten geht. Es muss ein <em>Kreis</em>
                        sein; Kantenzüge, die einen Knoten mehrmals durchlaufen, sind also
                        nicht erlaubt. Hier sehen Sie einen Graphen mit Hamiltonschem Kreis:
                    </p>
                    <figure class='centered-figure well container'>
                        <a class='left carousel-control-prev-icon' href='#isosahedron-has-HC' data-slide='prev'>
                            <div class='carousel-nav-icon'>
                                <img src='../img/carousel-prev-icon.svg'>
                            </div>
                        </a>
                        <a class='right carousel-control-next-icon' href='#isosahedron-has-HC' data-slide='next'>
                            <div class='carousel-nav-icon'>
                                <img src='../img/carousel-next-icon.svg'>
                            </div>
                        </a>
                        <div id='isosahedron-has-HC' class='carousel' data-interval='false'
                            style='display:inline-block'>
                            <ol class='carousel-indicators'>
                                <li data-target='#isosahedron-has-HC' data-slide-to='1' class='active'></li>
                                <li data-target='#isosahedron-has-HC' data-slide-to='2'></li>
                            </ol>
                            <div class='carousel-inner' style='display:inline-block'>
                                <div class='item active'><img
                                        src='../img/09-complexity-theory/hamilton-path-and-cycle/hamilton-01-01.svg'
                                        style='height:20em'></div>
                                <div class='item'><img
                                        src='../img/09-complexity-theory/hamilton-path-and-cycle/hamilton-01-02.svg'
                                        style='height:20em'></div>
                            </div class='carousel-inner'>
                        </div class='carousel'>
                    </figure>
                    <p>
                        Ein <em>Hamiltonscher Pfad</em> ist ein Pfad mit $|V|$ Knoten.
                        Auch hier gilt: kein Knoten darf mehrfach besucht werden.
                        Der untere Graph, der <em>Petersen-Graph</em>, hat keinen
                        Hamiltonschen Kreis, dafür aber einen Hamiltonschen Pfad:
                    </p>
                    <figure>
                        <img src='../img/09-complexity-theory/hamilton-path-and-cycle/hamilton-02-01.svg'
                            style='height:20em'>
                    </figure>
                    <p>
                        Wir definieren nun die zwei entsprechenden Entscheidungsprobleme:
                    </p>
                    <div class='well well-lg numbered-exercise container'>
                        <p>
                            <span class='numbered-title' id='problem-hamilton-cycle'
                                data-label-title='Problem'>Problem</span>
                            <span style="font-variant: small-caps;">(Hamilton Cycle).</span> Gegeben
                            ein Graph $G=(V,E)$, gibt es in $G$ einen Kreis der Länge $|V|$, der
                            also durch alle Knoten geht?
                        </p>
                    </div class='numbered-exercise'>
                    <div class='well well-lg numbered-exercise container'>
                        <p>
                            <span class='numbered-title' id='problem-hamilton-cycle'
                                data-label-title='Problem'>Problem</span>
                            <span style="font-variant: small-caps;">(Hamilton Path).</span> Gegeben
                            ein Graph $G=(V,E)$, gibt es in $G$ einen Pfad der Länge $|V|-1$, der
                            also alle $|V|$ Knoten enthält?
                        </p>
                    </div class='numbered-exercise'>

                    <div class='well container theorem'>
                        <p>
                            <span class='numbered-title' id='theorem-ham-cycle-to-path'
                                data-label-title='Theorem'>Theorem</span>
                            <span style="font-variant: small-caps;">Hamilton Cycle $\leq_p$ Hamilton Path</span>
                        </p>
                    </div class='well container theorem'>

                    <div class='well container'>
                        <p>
                            <strong>(Falscher) Beweis.</strong>
                            Tasten wir uns langsam heran. Wir stellen uns vor, eine
                            Bibliotheksfunktion <tt>has_hamilton_path(G)</tt> zu haben und
                            wollen mithilfe dieser eine neue Funktion <tt>has_hamilton_cycle(G)</tt>
                            schreiben.
                        </p>
                        <p>
                            Sei $u$ ein beliebiger Knoten. Wir wissen: wenn $G$ einen Hamiltonschen
                            Kreis hat, dann besucht dieser auch $u$ und im Anschluss einen Nachbarnknoten
                            $v$, also mit $\{u,v\} \in E$. Der Graph $G' := G - \{u,v\}$, in welchem
                            wir diese Kante löschen, besitzt somit einen Hamiltonschen Pfad.
                            Allerdings kann es sein, dass $G'$ sowieso einen Hamiltonschen Pfad
                            besitzt, der allerdings nicht $u$ und $v$ als Endknoten hat, so dass
                            er sich mit $\{u,v\}$ nicht zu einem Hamiltonschen Kreis schließt.
                            Wir müssen irgendwie die Frage beantworten können: besitzt
                            $G'$ einen Hamiltonschen Pfad, der $u$ und $v$ als Start- bzw. Endknoten hat?
                            Dies ist einfach: wir können neue Knoten $s$ und $t$
                            und die Kanten $\{s,u\}$ und $\{t,v\}$ einführen. Da $s$ und $t$ nun
                            Grad $1$ haben, muss ein Hamiltonscher Pfad, wenn er denn existiert,
                            $u$ und $v$ als Endknoten haben. Sei also $G'' := G' + \{s,u\} + \{t,v\}$.
                        </p>
                        <div class='well container-fluid subtheorem'>
                            <p>
                                <strong>Beobachtung:</strong> $G$ hat genau dann einen Hamiltonschen Kreis durch
                                die Kante $\{u,v\}$, wenn
                                $G''$ einen Hamiltonschen Pfad hat.
                            </p>
                        </div class='well container theorem'>
                        <figure class='centered-figure well container-fluid'>
                            <a class='left carousel-control-prev-icon' href='#ham-cycle-to-path' data-slide='prev'>
                                <div class='carousel-nav-icon'>
                                    <img src='../img/carousel-prev-icon.svg'>
                                </div>
                            </a>
                            <a class='right carousel-control-next-icon' href='#ham-cycle-to-path' data-slide='next'>
                                <div class='carousel-nav-icon'>
                                    <img src='../img/carousel-next-icon.svg'>
                                </div>
                            </a>
                            <div id='ham-cycle-to-path' class='carousel' data-interval='false'
                                style='display:inline-block'>
                                <ol class='carousel-indicators'>
                                    <li data-target='#ham-cycle-to-path' data-slide-to='1' class='active'></li>
                                    <li data-target='#ham-cycle-to-path' data-slide-to='2'></li>
                                </ol>
                                <div class='carousel-inner' style='display:inline-block'>
                                    <div class='item active'><img
                                            src='../img/09-complexity-theory/hamilton-path-and-cycle/hamilton-03-01.svg'
                                            style='height:20em'></div>
                                    <div class='item'><img
                                            src='../img/09-complexity-theory/hamilton-path-and-cycle/hamilton-03-02.svg'
                                            style='height:20em'></div>
                                </div class='carousel-inner'>
                            </div class='carousel'>
                        </figure>
                        <p>
                            Woher wollen wir allerdings wissen, ob der Kreis in $G$ (wenn es ihn denn
                            gibt) überhaupt durch $\{u,v\}$ geht? Vielleicht gibt es ja einen,
                            aber keinen durch $\{u,v\}$, so dass dann <tt>has_hamilton_path($G''$)</tt>
                            mit <tt>False</tt> antwortet, obwohl wir gerne ein <tt>True</tt> hätten.
                            Um das zu verhindern, können wir ja <em>alle</em> Nachbarn von $u$
                            durchprobieren. Wenn einer klappt, dann haben wir unseren Kreis;
                            wenn es überhaupt einen Kreis gibt, dann klappt es auch mit einem Nachbarn
                            (in der Tat: sogar mit zweien).
                        </p>
                        <pre class='listing container-fluid'>
<code>def has_hamilton_cycle(G):</code>
<code>    u = ein beliebiger Knoten</code>
<code>    for v in neighbors[u]:</code>
<code>        H = G - {u,v} + {s,u} + {t,v}</code>
<code>        if has_hamilton_path(H):</code>
<code>            return True</code>
<code>    return False</code></pre>
                        <p>
                            Falls nun <tt>has_hamilton_path</tt> polynomielle Laufzeit $O(n^k)$ hat,
                            so hat <tt>has_hamilton_cycle</tt> eine Laufzeit von $O(n^{k+1})$, auch
                            polynomiell.
                        </p>
                        <span class='qed'>\(\square\)</span>
                    </div class='proof'>
                    <p>
                        Was ist nun an diesem Beweis falsch? Nun, der Begriff der Reduktion,
                        dem wir uns ja mit der Notation $\leq_p$ verpflichten, verlangt, dass wir
                        auf Eingabe $G$ <em>einen</em> Graphen $G'$ bauen, mit der Eigenschaft,
                        dass $G$ genau dann einen Hamiltonschen Kreis hat, wenn $G'$ einen
                        Hamiltonschen Pfad hat. Uns steht also genau <em>ein</em> Aufruf von
                        <tt>has_hamilton_path</tt> zu. Aber ganz wertlos ist der obige
                        Beweis dennoch nicht, zeigt er doch, dass,
                        falls <span style="font-variant: small-caps;">Hamilton Path $\in $ P</span> ist, dann
                        auch <span style="font-variant: small-caps;">Hamilton Cycle $\in $ P</span>.
                        Der Fachbegriff für das, was unsere obige Funktion
                        <tt>has_hamilton_cycle</tt> tut, nennt sich <em>Cook-Reduktion</em>, nach
                        Stephen Cook, einem der Väter der Klasse NP.
                        Eine Reduktion, die dem strengen Reduktionsbegriff folgt,
                        also <span class='reference' data-ref='definition-polynomial-reduction'></span>,
                        nennt man in Abgrenzung dazu <em>Karp-Reduktion</em> nach Richard Karp,
                        ein weiterer NP-Vater.
                    </p>
                    <div class='well well-lg numbered-exercise container'>
                        <p>
                            <span class='numbered-title' id='put-unique-name-here'
                                data-label-title='Übungsaufgabe'>Übungsaufgabe</span>
                            Geben Sie einen "richtigen" Beweis für
                            <span class='reference' data-ref='theorem-ham-cycle-to-path'></span>, also
                            eine Karp-Reduktion.
                        </p>
                    </div class='numbered-exercise'>
                    <div class='well well-lg numbered-exercise container'>
                        <p>
                            <span class='numbered-title' id='put-unique-name-here'
                                data-label-title='Übungsaufgabe'>Übungsaufgabe</span>
                            Zeigen Sie <span style="font-variant: small-caps;">Hamilton Path $\leq_p$ Hamilton
                                Cycle</span>. Wenn es Ihnen einfacher scheint, geben Sie erst einmal
                            eine Cook-Reduktion.
                        </p>
                    </div class='numbered-exercise'>
                </div class='subChapter'>
            </div class='chapter'>
        </div class="content">
    </div class="rightSideWrapper">