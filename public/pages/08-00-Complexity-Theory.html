<div id="rightSideWrapper">


        <div class="content">



            <div class='chapter'>
                <div class='subChapter'>
                    <h1 class='hidden-title'>
                        <span class='chapterTitle'>8. Komplexitätstheorie</span>
                    </h1>

                    <p>
                        Turingmaschinen erlauben uns, den Resourcenverbrauch einer Berechnung zu quantifizieren:
                        zum einen die <em>Zeit</em>, also die Anzahl der Schritte, die die Turingmaschine
                        durchführt, bis sie anhält; zum anderen der <em>Speicherplatz</em>, also die Anzahl
                        der Zellen auf dem Band (oder den Bändern), die im Verlauf der Berechnung beschrieben werden.
                        Beides sind Maße, die tatsächlich im echten Leben relevant sind. Turingmaschinen erlauben uns,
                        diese genau zu quantifizieren und die Zeitkomplexität und Speicherkomplexität eines Problems
                        zu untersuchen. In diesem Kapitel werden wir uns zum Großteil auf Zeitkomplexität beschränken.
                    </p>
                    <p>Es gibt weitere Resourcen, die man mit Turingmaschinen nicht wirklich quantifizieren kann:</p>
                    <ul>
                        <li><strong>I/O-Komplexität.</strong> In echten Rechnern haben wir eine Hierarchie von
                            Speichermedien. Den extrem schnellen Prozessorcache; schnellen Cache; den vergleichsweise
                            langsamen
                            Hauptstpeicher (RAM); eventuell sogar einen externen Festplattenspeichern, der um
                            Größenordnungen langsamer ist.
                        </li>
                        <li><strong>Kommunikationskomplexität.</strong> Bei verteilten Anwendungen (Cloud Computing) ist
                            die limitierende Resource eventuell gar nicht die Rechenkapazität sondern das
                            <em>Netzwerk</em>, über
                            das die Daten ausgetauscht werden.
                        </li>
                    </ul>
                    <p>
                        Also: Turingmaschinen sind zwar universell in dem Sinne, dass sie wohl alle physikalisch
                        realisierbaren
                        Rechnermodelle simulieren können (ich sage <em>wohl</em>, weil wir nicht wissen, was alles
                        physikalisch realisierbar ist). Allerdings ist es möglich, dass Sie, abhängig von Ihrem
                        Anwendungsfeld, ein abgewandeltes oder völlig anderes Modell benötigen, um den
                        Resourcenverbrauch modellieren zu können.
                    </p>
                    <p>
                        Dennoch: in diesem Kapitel beschränken wir uns auf die Resource <em>Zeit</em>, und daher
                        sind Turingmaschinen das Modell der Wahl.
                    </p>
                    <h2>Zeitkomplexitätsklassen</h2>

                    <p>
                        Wir beschränken uns der Einfachheit halber auf das Eingabealphabet $\Sigma = \{0,1\}$ und
                        auf Entscheidungsprobleme, wo uns also nur eine Ja/Nein-Antwort interessiert.
                    </p>

                    <div class='well container theorem'>
                        <p><span class='numbered-title'>Definition</span> Sei $t: \N \rightarrow \N$. Eine
                            Turingmaschinen $M$
                            <em>entscheidet</em> eine Sprache $L \subseteq \Sigma^*$ in Zeit $t$ wenn
                        </p>
                        <ul>
                            <li>sie die Sprache entscheidet, also $x \in L \Longleftrightarrow f_M(x) = \texttt{accept}$
                                und
                            </li>
                            <li>
                                für jede Eingabe $x$ in maximal $O(t(|x|))$ Schritten terminiert.
                            </li>
                        </ul>
                        <p>
                            Wir definieren nun
                        </p>
                        \begin{align*}
                        \TIME_k(t) := \{L \subseteq \Sigma^* \ | \
                        \textnormal{es gibt eine $k$-Band-TM $M$, die $L$ in Zeit $t$ entscheidet}\}
                        \end{align*}
                        <p>
                            und schließlich
                        </p>
                        \begin{align*}
                        \TIME(t) := \bigcup_{k \geq 1} \TIME_k(t) \ .
                        \end{align*}
                    </div class='well container theorem'>
                    <p>
                        Falls Sie sich nicht mehr genau an die $O$-Notation erinnern können: in diesem Zusammenhang
                        heißt das, dass es Konstanten $c$ und $d$ gibt, so dass $M$ in maximal
                        $c t(|x|) + d$ Schritten terminiert. Die Konstanten $c$ und $d$ dürfen von $M$ abhängen, aber
                        nicht von der Eingabe $x$ oder der Länge $|x|$.
                        Wir haben in <a href="07-02-Turing-variants.html">Kapitel 7.3</a> gezeigt, wie man eine
                        $k$-Band-Turingmaschine $M$ durch eine
                        Ein-Band-Turingmaschine $M'$. Der Aufwand war quadratisch: wenn $M$ innerhalb von $t$ Schritten
                        terminiert, so terminiert $M'$ innerhalb von $c t^2$ Schritten, wobei $c$ eine Konstante ist,
                        die
                        von $M$ abhängt. Mit unser neuen Notation können wir das sehr konzis schreiben:
                    </p>
                    <div class='well container theorem'>
                        <p><span class='numbered-title'>Theorem</span> <strong>($k$-Band zu $1$-Band).</strong>
                            Sei $t: \N \rightarrow \N$. Dann gilt
                            $\TIME_k(t) \subseteq \TIME_1(t^2)$.
                        </p>
                    </div class='well container theorem'>

                    <p>
                        Der quadratische Overhead wird tatsächlich störend, wenn man Zeit als Resource untersucht.
                        Daher gibt es eine bessere Simulation; die benötigt allerdings zwei Bänder (Oder drei? Weiß ich
                        gerade nicht
                        exakt) und die Konstruktion ist deutlich komplizierter. Daher vorerst ohne Beweis:
                    </p>

                    <div class='well container theorem' id="k-tape-to-2-tape">
                        <p><span class='numbered-title'>Theorem</span> <strong>($k$-Band zu $2$-Band; ohne
                                Beweis).</strong> Sei
                            $t: \N \rightarrow \N$. Dann gilt $\TIME_k(t) \subseteq \TIME_2(t \log t)$.</p>
                    </div class='well container theorem'>

                </div class='subChapter'>
            </div class='chapter'>




        </div class="content">
    </div class="rightSideWrapper">