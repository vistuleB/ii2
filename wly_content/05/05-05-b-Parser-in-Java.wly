|> section
    title_gr=Parser in Java implementieren
    title_en=b Parser in Java
    number=5.5
    counter=DefCtr
    counter=ExoCtr
    |> div
        id=link-to-toc
        |> a
            href=../vorlesungsskript.html
            Inhaltsverzeichnis
        |> a
            href=05-05-a-LR-parsing-by-hand.html
            &lt;&lt; Kapitel 5.5
    |> div
        id=link-to-overview
        style=text-align: end
        |> a
            href=/
            zur Kursübersicht
        |> a
            href=05-05-c-LR-grammars.html
            Kapitel 5.5 &gt;&gt;
    |> div
        id=rightSideWrapper
        |> div
            class=content
            |> div
                class=chapter
                |> div
                    class=subChapter
                    |> h1
                        class=hidden-title
                        |> span
                            class=subChapterTitle
                            ::::ChapterCtr.::++SectionCtr
                            Einen Parser in Java implementieren
                    |> div
                        class=alert-info
                        Den vollständigen Quelltext, den wir in der Vorlesung geschrieben haben,
                        finden Sie in der Datei 
                        |> a
                            href=../code/parsing/arithmetic-in-class/ArithmeticGrammar.java
                            ArithmeticGrammar.java
                        .
                    |> p
                        Ich möchte nun eine kontextfreie Grammatik für arithmetische Ausdrücke der
                        Form `((31+402)*83)` entwerfen. Der Einfachheit halber bestehe ich
                        auf strenger Klammerung, so wäre `(2*(1+2+3))` zum Beispiel nicht erlaubt.
                        Unsere Grammatik soll allgemeine Dezimalzahlen darstellen können.
                        Das Alphabet ist somit
                        $\Sigma = \{\texttt{0},\texttt{1},\texttt{2},\texttt{3},\texttt{4},
                        \texttt{5},\texttt{6},\texttt{7},\texttt{8},\texttt{9},
                        \texttt{+},\texttt{*},\texttt{(},\texttt{)}\}$.
                        Die Produktionsregeln sind:
                    \begin{align*}
                    E&amp;\rightarrow N \tag{JustNumber} \\
                    E&amp;\rightarrow \texttt{(}E \texttt{+} E\texttt{)} \tag{Sum} \\
                    E&amp;\rightarrow \texttt{(}E \texttt{*} E\texttt{)} \tag{Product}\\
                    N&amp;\rightarrow D \tag{SingleDigit} \\
                    N&amp;\rightarrow ND \tag{NumberDigit} \\
                    D&amp;\rightarrow \texttt{0}\ | \ \texttt{1}\ | \ \texttt{2}\ | \ \texttt{3}\ | \ \texttt{4}\ | \
                    \texttt{5}\ | \ \texttt{6}\ | \ \texttt{7}\ | \ \texttt{8}\ | \ \texttt{9}
                    \end{align*}
                    |> p
                        Die Nichtterminale sind also $E$ (Expression), $N$ (Number) und $D$ (Digit). Wir haben auch
                        den einzelnen Produktionen Namen gegeben, bis auf die der Form $D \rightarrow i$.
                        Was soll nun unser Parser tun? Er soll, gegeben ein Eingabewort $w \in L$, den
                        _Ableitungsbaum_ konstruieren, für `((31+402)*83)` also
                    |> figure
                        |> img
                            style=height:20em
                            src=../img/context-free/arithmetic-syntax-tree.svg
                    |> p
                        Wie wir diesen Baum in Java repräsentieren, darüber sprechen wir in einer Minute.
                        Zuerst aber: wir wollen mit diesem Baum etwas Sinnvolles tun. Zum Beispiel
                        _auswerten_, so dass am Ende eine Zahl rauskommt, im obigen Beispiel
                        also $(31 + 402) \cdot 83 = 35939$. Oder den Ausdruck umformen von
                        Infix-Notation zu Präfixnotation, also`(* (+ 31 402) 83)`. All dies wird sehr einfach sein, sobald wir
                        den Ableitungsbaum als Datenstruktur vorliegen haben.
                    |> h2
                        Eine Datenstruktur für Ableitungsbäume
                    |> p
                        Für meine Implementierung in Java erschaffe ich für jedes Nichtterminal $X$
                        ein Interface
                        und für jede Produktionsregel $X \rightarrow \alpha$ eine Klasse,
                        die das Interface $X$ implementiert und $\alpha$ als Klassenvariable enthält.
                    |> ul
                        |> li
                            `interface Expression` wird implementiert von
                            |> ul
                                |> li
                                    `class Sum`, die als Klassenvariable `Exrepssion e1, e2` enthält,
                                |> li
                                    `class Product`, die als Klassenvariable `Exrepssion e1, e2` enthält,
                                |> li
                                    `class JustNumber`, die als Klassenvariable nur eine `Number number`enthält;
                        |> li
                            `interface Number` wird implementiert von
                            |> ul
                                |> li
                                    `class MultiDigitNumber`, die als Klassenvariable eine`Number` und eine `Digit` erhält und
                                |> li
                                    `class SingleDigitNumber`, die als Klassenvariable ein `Digit`enthält;
                        |> li
                            `interface Digit` wird implementiert von`class DigitOne`,`class DigitTwo`,`class DigitThree`,`class DigitFour`,`class DigitFive`,`class DigitSix`,`class DigitSeven`,`class DigitEight` und`class DigitNine`.
                    |> p
                        In unserem Anwendungsfall hat jedes Interface eine Methode`public int toInt()`. Interface `Expression` hat zusätzlich noch
                        die Methode `String toPrefixNotation()`. Ich schreibe auch ein
                        Über-Interface `ParseObject`, das alle Interfaces zusammenfasst.
                        Um uns das Debugging zu erleichtern, überschreibe ich in jeder Klasse die Methode`public String toString()`.