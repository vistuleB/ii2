|> section
    title_gr=Formale Definition und Beispiele
    title_en=Turing machines definition
    number=7.1
    counter=DefCtr
    counter=ExoCtr
    |> div
        id=link-to-toc
        |> a
            href=../vorlesungsskript.html
            Inhaltsverzeichnis
        |> a
            href=07-00-Turing-machines.html
            &lt;&lt; Kapitel 7.0
    |> div
        id=link-to-overview
        style=text-align: end
        |> a
            href=/
            zur Kursübersicht
        |> a
            href=07-02-Turing-machines-examples.html
            Kapitel 7.2 &gt;&gt;
    |> div
        id=rightSideWrapper
        |> div
            class=content
            |> div
                class=chapter
                |> div
                    class=subChapter
                    |> h1
                        class=hidden-title
                        |> span
                            class=subChapterTitle
                            ::::ChapterCtr.::++SectionCtr
                            Turingmaschinen: Formale Definition und Beispiele
                    |> p
                        Eine Turingmaschine besteht aus einem _Band_, das in Zellen unterteilt ist und
                        in beide Richtungen unbegrenzt ist,
                        und einem _Schreib-Lese-Kopf_.
                        Dieser befindet sich in jedem Schritt auf einer
                        Zelle. Wie auch der endliche Automat oder der
                        Kellerautomat hat die Turingmaschine einen internen _Zustand_.
                        In jedem Schritt liest die Maschine das Zeichen, das sich in der aktuellen
                        Zelle des Bandes befindet (dort, wo der Kopf steht). Abhängig vom gelesenen Zeichen
                        \(s\) und dem internen Zustand \(q\) schreibt die Turingmaschine ein neues Symbol
                        \(s'\) in die Zelle, wechselt in einen neuen Zustand \(q'\) und bewegt
                        den Kopf um maximal eine Zelle, also nach link, rechts, oder gar nicht.
                    |> figure
                        class=centered-figure well container
                        |> a
                            data-slide=prev
                            href=#turing-machine-example-01
                            class=left carousel-control-prev-icon
                            |> div
                                class=carousel-nav-icon
                                |> img
                                    src=../img/carousel-prev-icon.svg
                        |> a
                            data-slide=next
                            href=#turing-machine-example-01
                            class=right carousel-control-next-icon
                            |> div
                                class=carousel-nav-icon
                                |> img
                                    src=../img/carousel-next-icon.svg
                        |> div
                            style=display:inline-block
                            data-interval=false
                            class=carousel
                            id=turing-machine-example-01
                            |> ol
                                class=carousel-indicators
                                |> li
                                    class=active
                                    data-slide-to=1
                                    data-target=#turing-machine-example-01
                                |> li
                                    data-slide-to=2
                                    data-target=#turing-machine-example-01
                                |> li
                                    data-slide-to=3
                                    data-target=#turing-machine-example-01
                                |> li
                                    data-slide-to=4
                                    data-target=#turing-machine-example-01
                                |> li
                                    data-slide-to=5
                                    data-target=#turing-machine-example-01
                                |> li
                                    data-slide-to=6
                                    data-target=#turing-machine-example-01
                                |> li
                                    data-slide-to=7
                                    data-target=#turing-machine-example-01
                                |> li
                                    data-slide-to=8
                                    data-target=#turing-machine-example-01
                            |> div
                                style=display:inline-block
                                class=carousel-inner
                                |> div
                                    class=item active
                                    |> img
                                        style=height:15em
                                        src=../img/turing-machines/exampe-1/01.svg
                                |> div
                                    class=item
                                    |> img
                                        style=height:15em
                                        src=../img/turing-machines/exampe-1/02.svg
                                |> div
                                    class=item
                                    |> img
                                        style=height:15em
                                        src=../img/turing-machines/exampe-1/03.svg
                                |> div
                                    class=item
                                    |> img
                                        style=height:15em
                                        src=../img/turing-machines/exampe-1/04.svg
                                |> div
                                    class=item
                                    |> img
                                        style=height:15em
                                        src=../img/turing-machines/exampe-1/05.svg
                                |> div
                                    class=item
                                    |> img
                                        style=height:15em
                                        src=../img/turing-machines/exampe-1/06.svg
                                |> div
                                    class=item
                                    |> img
                                        style=height:15em
                                        src=../img/turing-machines/exampe-1/07.svg
                                |> div
                                    class=item
                                    |> img
                                        style=height:15em
                                        src=../img/turing-machines/exampe-1/08.svg
                    |> p
                        Sie können sich das Band auch als Magnetband vorstellen, das nach vorn oder nach hinten gespult
                        wird, anstatt dass der Kopf sich bewegt. Am Anfang steht auf dem Band das
                        _Eingabewort_ und der Kopf auf dem ersten Symbol dieses Wortes. Die Turingmaschine
                        wendet
                        nun ihre Regeln an, bis Sie einen
                        _Endzustand_ erreicht. Bei _Entscheidungsproblemen_, wo uns nur
                        eine Ja/Nein-Antwort interessiert, wird die Antwort durch den Entzustand angegeben:
                        der Zustand $\qaccept$ entspricht einem _Ja_, der Zustand
                        $\qreject$ entspricht einem _Nein_. Diese zwei Endzustände reichen im Allgemeinen
                        aus. Wenn wir von der Maschine eine komplexere Ausgabe als Ja/Nein erwarten, so
                        betrachten wir als _Ausgabe der Turingmaschine_ den Inhalt des Bandes zu dem
                        Zeitpunkt, da die Maschine den Zustand $\qaccept$ erreicht.
                        Was brauchen wir also, um so eine Turingmaschine
                        und ihre Arbeitsweise zu beschreiben?
                    |> div
                        class=well container theorem
                        |> p
                            |> span
                                class=numbered-title
                                Definition 
                                |> NumberedTitle
                                    ::::ChapterCtr.::::SectionCtr.::++DefCtr
                                \ 
                            *(Turingmaschine).* Eine
                            Turingmaschine besteht aus folgenden Elementen:
                        |> ol
                            |> li
                                Einem endlichen Eingabe-Alphabet \(\Sigma\). Dies sind die Symbole, die für das
                                Eingabewort in
                                Frage kommen.
                            |> li
                                Einem endlichen Bandalphabet \(\Gamma\); das sind die Symbole, die auf dem Band
                                stehen dürfen. Offensichtlich muss \(\Sigma \subseteq \Gamma\) gelten. Jede
                                Zelle kann genau ein Zeichen aus \(\Gamma\) enthalten. Darüberhinaus
                                gibt es noch das sogenannte Blanksymbol \(\square \in \Gamma \setminus \Sigma\). Dies
                                zeigt an, dass die Zelle im Moment leer ist. Im obigen Beispiel ist
                                die Zelle links vom ersten \(a\) beispielsweise leer.
                                Am Anfang steht auf dem Band also ein Eingabewort \(w \in \Sigma^*\) und
                                rechts und links davon unendlich viele \(\square\)-Symbole.
                            |> li
                                Einer endliche Menge \(Q\) an inneren Zuständen. Dies entspricht in etwa
                                den Prozessor-Registern eines Computers. Ein Zustand \(\texttt{start} \in Q\)
                                ist der Startzustand, in welchem sich die Maschine zu Beginn befindet.
                            |> li
                                Einer Zustandsübergangsfunktion \(\delta\), die sagt, was die Turingmaschine tun soll,
                                wenn Sie im Zustand \(q\) ist und Zeichen \(s\) liest. Formal:
                                \begin{align*}
                                \delta : Q \times \Gamma \rightarrow Q \times \Gamma \times \lsr \ ,
                                \end{align*}
                                wobei 
                                |> tt
                                    L
                                \ für _gehe eine Zelle nach links_ steht,
                                |> tt
                                    R
                                \ für rechts und 
                                |> tt
                                    S
                                \ für _stay_, also die Anweisung, den Kopf
                                nicht zu bewegen.
                            |> li
                                Zwei besonderen Zuständen $\qaccept$ und $\qreject$.
                    |> p
                        Für die Turingmaschine in dem obigen Beispiel haben wir zwei Regeln gesehen:
                        \begin{align*}
                        \delta(q_2, b)&amp;= (q_3, a, \texttt{R}) \\
                        \delta(q_3, \#)&amp;= (q_4, b, \texttt{L})
                        \end{align*}
                    |> h3
                        Was macht eine Turingmaschine?
                    Sie haben nun wohl bereits eine vage Vorstellung, was eine Turingmaschine macht.
                    Versuchen wir, es noch weiter zu formalisieren. Um den _Gesamtzustand_ der
                    Turingmaschine zu beschreiben, also eine vollständige Momentaufnahme, reicht
                    nicht der aktuelle innere Zustand \(q\); wir brauchen auch den Bandinhalt und insbesondere
                    die Position, an der sich der Kopf befindet. Das alles zusammen nennt
                    man die _Konfiguration der Turingmaschine_. Wir wollen sie mit
                    uns bereits bekannten mathematischen Begriffen beschreiben.
                    |> figure
                        |> img
                            style=height:20em
                            src=../img/turing-machines/configuration.svg
                            loading=lazy
                    |> div
                        class=well container theorem
                        |> span
                            class=numbered-title
                            Definition 
                            |> NumberedTitle
                                ::::ChapterCtr.::::SectionCtr.::++DefCtr
                            \ 
                        Die _Konfiguration_ einer Turingmaschine ist ein Element in
                        \(\Gamma^* \times Q \times \Gamma^*\), also
                        \begin{align*}
                        C = u q v
                        \end{align*}
                        wobei \(uv \in \Gamma^*\) der Bandinhalt ist, der
                        Schreib-Lese-Kopf auf dem ersten Zeichen von \(v\) steht und \(q\) der
                        innere Zustand der Turingmaschine ist. Das \(q\) in \(C\)
                        kennzeichnet also sowohl die Position des Schreib-Lese-Kopfes auf dem Band
                        sowie den inneren Zustand
                        Die Menge aller Konfigurationen ist
                        \begin{align*}
                        \mathcal{C} := \Gamma^* \times Q \times \Gamma^*
                        \end{align*}
                        Der _Zustand einer Konfiguration_ \(C = uqv\) ist \(q\), also der innere
                        Zustand, in dem sich die Maschine gerade befindet.
                        Wir bezeichnen mit $\state(C)$. Formal:
                        \begin{align*}
                        \state: \mathcal{C}&amp;\rightarrow Q \\
                        uqv&amp;\mapsto q \ .
                        \end{align*}
                        Eine Konfiguration \(C\) ist
                        eine _akzeptierende Endkonfiguration_ wenn $\state(C) = \qaccept$ ist;
                        eine _ablehnende Endkonfiguration_ , wenn $\state(C) = \qreject$ ist.
                        In beiden Fällen ist \(C\) eine _Endkonfiguration_.
                    |> p
                        Wenn also das Eingabewort \(w \in \Sigma^*\) und $\qstart$ der Startzustand ist, dann ist
                        \begin{align*}
                        C_{\rm start} = \qstart{} w
                        \end{align*}
                        die _Startkonfiguration_.
                    |> div
                        class=alert-info
                        *Die Rolle des \(\square\)-Symbols*. Das Band der Turingmaschine ist ja
                        unendlich.
                        Um eine Momentaufnahme dennoch als endliches Objekt beschreiben zu können,
                        lassen wir die \(\square\)-Symbole links und rechts vom "eigentlichen" Bandinhalt weg.
                        Bei einer Konfiguration \(uqv\) stehen also links vom \(u\) und rechts vom \(v\) unendlich
                        viele \(\square\)-Symbole auf dem Band. Nach der formalen Definition
                        \(uqv \in \Gamma^* \times Q \times \Gamma^*\) ist es nicht verboten, dass \(u\) auch mit
                        einem \(\square\)-Symbol beginnt oder \(v\) mit einem aufhört. Allerdings wären die
                        Konfiguration
                        \(\square u q v\) und \(u q v \square\) genauso gut mit
                        \(u q v\) beschrieben. Wir können uns also auf die Konvention einigen, dass
                        \(\square\) nie am Rande einer Konfiguration \(uqv\) steht.
                        Beachten Sie auch, dass die Zellen nicht "numeriert" sind. Die beiden folgenden
                        Momentaufnahmen
                        |> figure
                            |> img
                                style=height:18em
                                src=../img/turing-machines/configuration-two.svg
                                loading=lazy
                        können also beide mit der Konfiguration \(aAAaq\#ba\) beschrieben werden, obwohl
                        die Zellen nun andere Inhalte haben, weil die Turingmaschine es irgendwie geschafft
                        hat, den ganzen Bandinhalt um eins nach rechts zu kopieren. Es sollte klar
                        sein, dass die Turingmaschine keine Möglichkeit hat, die obere von der unteren
                        Situation zu unterscheiden, und dass es somit nur recht und billig ist, beide
                        als eine identische Konfiguration aufzufassen.
                        |> p
                            All diese Schwierigkeiten verschwinden, wenn wir uns den Speicher einer Turingmaschine
                            nicht
                            als unendliches Band vorstellen, sondern als zwei Stapel, einer links vom Kopf und einer
                            rechts vom Kopf. Allerdings hat sich die Vorstellung vom Band irgendwie als
                            Standard durchgesetzt. Hier sehen Sie die gleiche Konfiguration in dem Modell
                            mit zwei Stapeln:
                        |> figure
                            |> img
                                style=height:18em
                                src=../img/turing-machines/two-stacks.svg
                                loading=lazy
                        |> p
                            Alternativ können wir auch der Turingmaschine verbieten, das Blank-Symbol $\Box$ jemals
                            zu schreiben. Dann wäre also
                            $\delta: Q \times \Gamma \rightarrow Q \times (\Gamma \setminus \{\Box\}) \times \lsr$.
                            All diese Betrachtungsweisen unterscheiden sich nicht wesentlich. Wir bleiben
                            bei unserem "alten" $\delta$, erlauben also, $\Box$ zu schreiben, und
                            leben damit, dass $uqv$ und $\Box \Box u q v \Box$ formal zwei verschiedene Konfigurationen
                            sind, auch wenn beide irgendwie das selbe beschreiben.
                    |> p
                        Formal definiert \(\delta\) nun auch
                        eine Funktion auf der Menge der Konfigurationen:
                    |> div
                        class=well container theorem
                        |> span
                            class=numbered-title
                            Definition 
                            |> NumberedTitle
                                ::::ChapterCtr.::::SectionCtr.::++DefCtr
                            \ 
                        *(erweiterte Zustandsübergangsfunktion)*
                        Die erweiterte Zustandsübergangsfunktion einer Turingmaschine ist
                        \begin{align*}
                        \hat{\delta} : \mathcal{C} \rightarrow \mathcal{C} \
                        \end{align*}
                        Sie beschreibt für eine Konfiguration \(C\), welches die Konfiguration
                        im nächsten Schritt ist.
                        Per Konvention
                        legen wir fest, dass
                        \(\hat{\delta}(C) = C\) gilt, wenn \(C\) eine Endkonfiguration ist.
                    Unsere obige Turingmaschine hat beispielsweise die Regeln
                    \(\delta(q_2,b) = (q_3, a,R)\) und
                    \(\delta(q_3, \#) = (q_4, b, \texttt{L})\), und somit würden
                    \begin{align*}
                    \hat{\delta}(aaAq_2b\#ba)&amp;= aaAaq_3\#ba \\
                    \hat{\delta}(aaAaq_3\#ba)&amp;= aaAq_4abba \\
                    \hat{\delta}(abAq_2bba\#)&amp;= abAaq_3ba\# \\
                    \end{align*}
                    gelten. Sie sehen:
                    Die Definition von $\hat{\delta}$ ist nichts wirklich Tiefgründiges, sondern einfach
                    eine Implementierung der Turingmaschinen-Momentaufnahme mit uns bereits
                    geläufigen mathematischen "Datenstrukturen" (hier: der Menge $\Gamma^* \times Q \times \Gamma^*$).
                    Stellen Sie sich einfach
                    vor, Sie müssten eine Turingmaschine in Java implementieren. Dann würden Sie es wahrscheilich
                    irgendwie so ähnlich machen.
                    |> h3
                        Ausgabekonfiguration einer Turingmaschine
                    Die Funktion \(\hat{\delta}\) bildet aus einer Konfiguration die
                    Folgekonfiguration. Wir definieren nun
                    \begin{align*}
                    \hat{\delta}^{(i)} (C) := \underbrace{\hat{\delta}(\hat{\delta}(\dots (\hat{\delta}}_{i \textnormal{
                    mal}} (C) \dots)))
                    \end{align*}
                    also die Konfiguration, die die Turingmaschine nach \(i\) Rechenschritten erreicht hat.
                    Weiterhin definieren wir
                    \(\hat{\delta}^* (C)\) als die Endkonfiguration, die bei wiederholter
                    Anwendung von $\hat{\delta}$ schlussendlich erreicht wird.
                    Hier taucht ein Problem auf: es ist nicht gesagt, dass die Turingmaschine,
                    von Konfiguration \(C\) beginnend, überhaupt irgendwann in einer Endkonfiguration landen
                    wird. Daher kann \(\hat{\delta}^*\) auch 
                    |> tt
                        undefined
                    \ sein:
                    \begin{align*}
                    \hat{\delta}^* (C) := \begin{cases}
                    \hat{\delta}^{(i)} (C)&
                    \textnormal{ wenn es ein \(i\) gibt, so dass $\hat{\delta}^{(i)} (C)$ eine Endkonfiguration ist} \\
                    \texttt{undefined}&amp;\textnormal{sonst.}
                    \end{cases}
                    \end{align*}
                    |> p
                        Nochmal zur Verdeutlichung: wenn $\delta^{(i)}(C)$ eine Endkonfiguration ist,
                        dann ist auch $\delta^{(j)}(C)$ eine, für jedes $j \geq i$, weil
                        wir $\hat{\delta}(C') = C'$ für jede Endkonfiguration $C'$ definiert haben.
                        Es spielt also in der obigen Formulierung
                        _wenn es ein $i$ gibt_ keine Rolle, welches solche $i$ wir wählen.
                    Für ein Eingabewort \(x \in \Sigma^*\) können wir nun das Ergebnis der Berechnung
                    von Turingmaschine \(M\) auf \(x = x_1 \dots x_n\) definieren:
                    \begin{align*}
                    \hat{M}(x) := \hat{\delta}^* (\qstart{} x_1 x_2 x_3 \dots x_n) \ .
                    \end{align*}
                    Wir beginnen also mit der Startkonfiguration und lassen die Turingmaschine dann
                    laufen, bis sie einen Endzustand erreicht. Die erreichte Konfiguration bezeichnen
                    wir mit \(\hat{M}(x)\). Falls nie ein Endzustand erreicht wird (die Turingmaschine also
                    endlos läuft),
                    ist \(\hat{M}(x)\) 
                    |> tt
                        undefined
                    .
                    |> h2
                        Sprachen entscheiden
                    |> p
                        Ein _Entscheidungsproblem_ ist eine Funktion \(P : \Sigma^* \rightarrow
                        \{\texttt{true}, \texttt{false}\}\), beispielsweise: _gegeben ein Wort,
                        stellt dieses Wort ein korrektes Java-Programm dar?_
                        oder _gegeben eine Zahl in Dezimalschreibweise, ist dies
                        eine Primzahl?_ Eine äquivalente Sichtweise ist die
                        eines Entscheidungsproblems als _Sprache_ \(L \subseteq \Sigma^*\).
                        Wir identifizieren \(L\) hier mit der Menge aller Wörter \(x\) mit
                        \(P(x) = \texttt{true}\). Wenn wir es mit einem Entscheidungsproblem
                        zu tun haben und dieses mit einer Turingmaschine lösen wollen,
                        so interessiert uns am Endergebnis \(\hat{M}(x)\) (also der erreichten Endkonfiguration)
                        nicht der Bandinhalt, sondern nur, ob der Zustand 
                        |> tt
                            accept
                        \ oder
                        |> tt
                            reject
                        \ ist. Wir definieren daher
                        \begin{align*}
                        f_M(x) = \begin{cases}
                        \texttt{accept}&amp;\textnormal{ falls $\state(\hat{M}(x)) = \qaccept$, wenn also $\hat{M}(x)$
                        eine akzeptierende Endkonfiguration ist, }\\
                        \texttt{reject}&amp;\textnormal{ falls $\state(\hat{M}(x)) = \qreject$ ,}\\
                        \texttt{undefined}&amp;\textnormal{ falls $\hat{M}(x) = \texttt{undefined}$ }
                        \end{cases}
                        \end{align*}
                    |> div
                        class=well container theorem
                        |> span
                            class=numbered-title
                            Definition 
                            |> NumberedTitle
                                ::::ChapterCtr.::::SectionCtr.::++DefCtr
                            \ 
                        *(Turingmaschine entscheidet eine Sprache)*
                        Eine Turingmaschine \(M\)
                        _entscheidet_ die Sprache \(L \subseteq \Sigma^*\) wenn
                        |> ol
                            |> li
                                \(f_M(x) = \texttt{accept}\) für alle \(x \in L\),
                            |> li
                                \(f_M(x) = \texttt{reject}\) für alle \(x \in \Sigma^* \setminus L\).
                        Insbesondere heißt das, dass \(M\) auf jedem Eingabewort terminiert.
                        |> p
                            Eine Sprache \(L\) heißt _entscheidbar_, wenn
                            es eine Turingmaschine gibt, die sie entscheidet.
                    |> div
                        class=well container theorem
                        |> span
                            class=numbered-title
                            Definition 
                            |> NumberedTitle
                                ::::ChapterCtr.::::SectionCtr.::++DefCtr
                            \ 
                        *(Turingmaschine akzeptiert eine Sprache)*
                        Eine Turingmaschine \(M\) _akzeptiert_ die Sprache
                        \(L \subseteq \Sigma^*\) wenn
                        \begin{align*}
                        x \in L \Longleftrightarrow f_M(x) = \texttt{accept}
                        \end{align*}
                        für alle \(x \in \Sigma^*\) gilt. Das heißt, dass \(M\) für \(x \not \in \Sigma^*\)
                        entweder irgendwann den Endzustand $\qreject$ erreicht oder
                        nie einen Endzustand erreicht.
                        |> p
                            Eine Sprache \(L \subseteq \Sigma^*\) heißt _semi-entscheidbar_,
                            wenn es eine Turingmaschine \(M\) gibt, die \(L\) akzeptiert.
                    |> p
                        In beiden Definition verlangen wir natürlich, dass
                        \(\Sigma\) das Eingabealphabet der Turingmaschine ist.
                    |> h2
                        Funktionen berechnen
                    |> p
                        Oft wollen wir nicht nur eine Sprache \(L \subseteq \Sigma^*\)
                        entscheiden, sondern eine Funktion \(g: \Sigma_1^* \rightarrow \Sigma_2^*\)
                        berechnen. Mit einer Turingmaschine heißt das einfach, dass
                        bei Eingabe \(x \in \Sigma_1^*\) die Turingmaschine in einer
                        akzeptierenden Endkonfiguration \(C\) landet, und in \(C\) steht
                        dann \(g(x)\) auf dem Band. Formal müssen wir noch klären, was _\(g(x)\) steht
                        auf dem Band_ bedeutet.
                    |> div
                        class=well container theorem
                        |> span
                            class=numbered-title
                            Definition 
                            |> NumberedTitle
                                ::::ChapterCtr.::::SectionCtr.::++DefCtr
                            \ 
                        *(Turingmaschine berechnet eine Funktion)*
                        Seien \(\Sigma_1, \Sigma_2\) zwei endliche Alphabete und
                        \begin{align*}
                        g : \Sigma_1^* \rightarrow \Sigma_2^*
                        \end{align*}
                        eine Funktion. Eine Turingmaschine \(M\) _berechnet die Funktion \(g\)_, wenn
                        |> ol
                            |> li
                                \(\Sigma_1\) das Eingabealphabet von \(M\) ist,
                            |> li
                                \(\Sigma_1 \cup \Sigma_2 \subseteq \Gamma\) gilt und
                                \(\square \in \Gamma \setminus (\Sigma_1 \cup \Sigma_2)\); das Blank-Symbol
                                ist also weder Teil das Eingabealphabets noch des Ausgabealphabets.
                            |> li
                                $M$ terminiert für jedes $x \in \Sigma^*$.
                            |> li
                                \ In der Endkonfiguration $\hat{M}(x)$ steht auf dem Arbeitsband das
                                Wort \(g(x) \in \Sigma_2^*\) und der Kopf steht ganz links, also
                                $\hat{M}(x) = \qaccept{} g(x)$.
                    |> h2
                        Turingmaschinen und formale Grammatiken
                    |> p
                        Da Turingmaschinen sowohl in dem Kurs
                        |> a
                            href=../../BerKrea/index.html
                            Berechenbarkeit und Kreativität
                        als auch
                        |> a
                            href=../../TI-2/index.html
                            Theoretische Informatik
                        vorkommen, teilen sich die beiden Kurse diese Seiten.
                        Für Berechenbarkeit und Kreativität ist der Rest dieses Teilkapitels
                        allerdings weniger relevant, da formale Grammatiken nicht Teil des Kurses waren.
                    |> div
                        class=well container theorem
                        |> span
                            class=numbered-title
                            Theorem 
                            |> NumberedTitle
                                ::::ChapterCtr.::::SectionCtr.::++DefCtr
                            \ 
                        Sei \(M\) eine Turingmaschine und \(L(M)\) die von ihr akzeptierte Sprache.
                        Dann gibt es eine formale Grammatik \(G\) mit \(L(G) = L(M)\). In anderen Worten:
                        formale Grammatiken sind mindestens so mächtig wie Turingmaschinen.
                    |> div
                        class=well container
                        *Beweis.*
                        Die Idee ist, dass wir eine Grammatik \(G\) schreiben, die
                        "in umgekehrter Reihenfolge" läuft, also
                        \begin{align*}
                        \texttt{\$} q_{\rm start} w \texttt{.} \Step{}^* S
                        \end{align*}
                        ableiten kann genau dann, wenn \(w \in S\) gilt. Wir brauchen
                        \(\texttt{\$}\) und \(\texttt{.}\) als Randmarkierungen. Wir lassen hier
                        temporär zu, dass die linke Seite ausschließlich aus Terminalsymbolen bestehen kann.
                        |> p
                            Hierfür definieren wir für jede Regel der Turingmaschine eine Grammatik-Regel:
                            \begin{align*}
                            \begin{array}{lcl}
                            \delta(q,x) = (r,y,\texttt{S} )&amp;\textnormal{wird zur Produktion}&amp;qx \rightarrow ry \\
                            \delta(q,x) = (y,r,\texttt{R})&amp;\textnormal{wird zur Produktionen}&amp;qx \rightarrow yr \\
                            \delta(q,x) = (y,r,\texttt{L})&amp;\textnormal{wird zu den Produktionen}&amp;aqx \rightarrow ray
                            \textnormal{ für alle $a \in \Gamma$}
                            \end{array}
                            \end{align*}
                            Die Asymmetrie zwischen den Regeln, die den Kopf nach rechts verschieben und denen, die ihn
                            nach links verschieben, ergibt sich aus unserer Konvention, die Konfigurationen \(uqv\) so
                            zu
                            interpretieren, dass der Kopf auf dem ersten Symbol von \(v\)
                            und nicht etwa auf dem letzten von \(u\) steht.
                            Ein Problem ergibt sich, wenn \(q\) am Rand steht. Hierfür erlauben wir,
                            an den Rändern der Konfiguration \(\square\)-Symbole zu erzeugen:
                            \begin{align*}
                            \texttt{\$}&amp;\rightarrow \texttt{\$} \square \\
                            \texttt{.}&amp;\rightarrow \square \texttt{.} \
                            \end{align*}
                            Wenn der Kopf also vor dem \(\texttt{.}\) stehen sollte,
                            dann können wir
                            \begin{align*}
                            \texttt{\$}uq\texttt{.} \Step{} \texttt{\$}uq\square \texttt{.}
                            \end{align*}
                            anwenden und dann die Produktion, die der Regel von \(\delta(q,\square)\) entspricht.
                            Es sollte nun klar sein, dass folgendes gilt:
                        |> div
                            class=well subtheorem theorem
                            |> span
                                class=numbered-title
                                Beobachtung 
                                |> NumberedTitle
                                    ::::ChapterCtr.::::SectionCtr.::++DefCtr
                                \ 
                            Wenn \(\hat{\delta}^{(i)} (uqv) = u'q'v'\) gilt, die Turingmaschine also in
                            \(i\) Schritten von Konfiguration \(uqv\) nach \(u'q'v'\) übergeht, dann gilt in der gerade
                            entwickelten Grammatik auch
                            \begin{align*}
                            \texttt{\$}uqv\texttt{.} \Step{}^* \texttt{\$}\square^* u'q'v'\square^*\texttt{.}
                            \end{align*}
                        Als nächstes definieren wir _Aufräumregeln_: wenn \(q = \texttt{accept}\), dann
                        können wir jedes Zeichen löschen:
                        \begin{align*}
                        \texttt{accept}\ x&amp;\rightarrow \texttt{accept} \\
                        x\ \texttt{accept}&amp;\rightarrow \texttt{accept}
                        \end{align*}
                        wobei \(\texttt{accept}\) ein Nichtterminal der Grammatik ist.
                        Und somit gilt auch
                        \begin{align*}
                        \texttt{\$} u \ \texttt{accept} \ v \texttt{.}&amp;\Step{}^*
                        \texttt{\$}\ \texttt{accept} \ \texttt{.}
                        \end{align*}
                        Als letzte Regel definieren wir:
                        \begin{align*}
                        \texttt{\$ }\ \texttt{accept}\ \texttt{.} \rightarrow S
                        \end{align*}
                        Wir haben nun eine Grammatik mit den folgenden Eigenschaften:
                        \begin{align*}
                        M(x_1 x_2 \dots x_n) = \texttt{accept}&amp;\textnormal{ genau dann, wenn }
                        \texttt{\$} \texttt{start} x_1 x_2 \dots x_n \texttt{.} \Step{}^* S
                        \end{align*}
                        Wir bauen nun eine weitere Grammatik \(G\), in der wir jede Produktion \(\alpha \rightarrow
                        \beta\)
                        umdrehen, also durch \(\beta \rightarrow \alpha\) ersetzen. Zusätzlich definieren wir
                        Abschlussregeln
                        \begin{align*}
                        \texttt{\$}&amp;\rightarrow \epsilon \\
                        \texttt{.}&amp;\rightarrow \epsilon \\
                        \texttt{start}&amp;\rightarrow \epsilon
                        \end{align*}
                        die die Randmarkierungen ersetzen. In dieser Grammatik gilt nun für
                        alle Wörter \(x \in \Sigma^*\):
                        \begin{align*}
                        x \in L(M) \Longleftrightarrow S \rightarrow
                        G: S \Step{}^* x
                        \end{align*}
                        und somit gilt \(L(G) = L(M)\). Zusammenfassend besitzt \(G\) also die Produktionen
                        \begin{align*}
                        S&amp;\step{1} \texttt{\$} \ \texttt{accept} \ \texttt{.} \\
                        \texttt{accept}&amp;\step{2} x \ \texttt{accept} \ | \ \texttt{accept} \ x \quad
                        \tag{ für jedes \(x \in \Gamma\)} \\
                        ry&amp;\step{3} qx \quad \tag{ wenn $\delta(q,x) = (r,y, \texttt{S})$}\\
                        yr&amp;\step{4} qx \quad \tag{ wenn $\delta(q,x) = (r,y, \texttt{R})$}\\
                        ray&amp;\step{5} aqx \quad \tag{ wenn $\delta(q,x) = (r,y, \texttt{L})$, für jedes \(a \in
                        \Gamma\)} \\
                        \texttt{\$} \square&amp;\step{6} \texttt{\$} \\
                        \texttt{.}\square&amp;\step{7} \texttt{.} \\
                        \texttt{\$}&amp;\step{8} \epsilon \\
                        \texttt{.}&amp;\step{9} \epsilon \\
                        \texttt{start}&amp;\step{10} \epsilon
                        \end{align*}
                        Um also ein Wort \(x \in L(M)\) abzuleiten, müssen wir
                        die akzeptierende Endkonfiguration \(C\) von \(M(x)\) "erraten" und dann
                        per Produktionen 1 und 2 die Wortform \(\texttt{\$}C\texttt{.}\) ableiten. Von da
                        an verwenden wir die Produktionen 3, 4, 5, 6, 7, um die Berechnung der Turingmaschine
                        \(M(x)\) von hinten nach vorne zu simulieren, bis wir bei
                        \(\texttt{\$} \texttt{start}\ x \texttt{.}\) angelangt sind. Dann
                        lassen wir \(\texttt{\$}, \texttt{start}, \texttt{.}\) mit den Produktionen 8, 9, 10
                        verschwinden und haben \(x\) abgeleitet.
                        |> span
                            class=qed
                            \(\square\)